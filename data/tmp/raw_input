What's Included in This Documenthttps://www.boost.org/doc/libs/1_59_0/doc/about.html    What's Included in This Document           Home Libraries People FAQ More        What's Included in This Document This document represents only a subset of the full Boost     documentation: that part which is generated from BoostBook or     QuickBook sources.  Eventually all Boost libraries may use these     formats, but in the meantime, much of Boost's documentation is not     available here.  Please     see http://www.boost.org/libs     for complete documentation.             Documentation for some of the libraries described in this document is       available in alternative formats:         HTML          PDF                  
Chapter&#160;1.&#160;Boost.Accumulatorshttps://www.boost.org/doc/libs/1_59_0/doc/accumulators.html    Chapter&#160;1.&#160;Boost.Accumulators           Home Libraries People FAQ More         Chapter&#160;1.&#160;Boost.Accumulators  Eric Niebler  Copyright &#169; 2005, 2006 Eric Niebler           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Preface User's Guide  The       Accumulators Framework The       Statistical Accumulators Library  Acknowledgements Reference  Accumulators Framework Reference Statistics Library Reference Numeric Operators Library Reference      Preface           &#8220;It is better to be approximately right than exactly wrong.&#8221;         -- Old adage                Description             Boost.Accumulators is both a library for incremental statistical computation       as well as an extensible framework for incremental calculation in general.       The library deals primarily with the concept of an accumulator,       which is a primitive computational entity that accepts data one sample at a       time and maintains some internal state. These accumulators may offload some       of their computations on other accumulators, on which they depend. Accumulators       are grouped within an accumulator set. Boost.Accumulators       resolves the inter-dependencies between accumulators in a set and ensures that       accumulators are processed in the proper order.         Last revised: August 04, 2015 at 09:03:30 GMT         
Chapter&#160;2.&#160;Boost.Alignhttps://www.boost.org/doc/libs/1_59_0/doc/align.html    Chapter&#160;2.&#160;Boost.Align           Home Libraries People FAQ More         Chapter&#160;2.&#160;Boost.Align  Glen Fernandes  Copyright &#169; 2014 Glen Joseph Fernandes           Distributed under the Boost         Software License, Version 1.0.           Table of Contents  Introduction Rationale Tutorial  align aligned_alloc and aligned_free aligned_allocator aligned_allocator_adaptor aligned_delete alignment_of assume_aligned is_aligned  Examples  aligned_ptr and make_aligned aligned_vector  Reference  align aligned_alloc and aligned_free aligned_allocator aligned_allocator_adaptor aligned_delete alignment_of assume_aligned is_aligned  Vocabulary Compatibility Acknowledgments History     Introduction         This library provides an alignment function, aligned allocation and deallocation       functions, an aligned allocator, an aligned allocator adaptor, an aligned deleter,       a type trait to query alignment requirements, a macro to hint pointer alignment,       and a function to verify pointer value alignment.       Table&#160;2.1.&#160;The Boost.Align Library                                       Component                                                             Description                                                                align                                                             Pointer alignment function                                                               aligned_alloc, aligned_free                                                             Aligned allocation and deallocation functions                                                               aligned_allocator                                                             Alignment aware allocator                                                               aligned_allocator_adaptor                                                             Alignment aware allocator adaptor                                                               aligned_delete                                                             Deleter for constructed objects allocated with the alignment function                                                               alignment_of                                                             Type trait to query alignment requirement of a type at compile time                                                               assume_aligned                                                             Macro for static pointer alignment hint                                                               is_aligned                                                             Pointer alignment verification function                                     Last revised: August 04, 2015 at 09:04:48 GMT         
Chapter&#160;3.&#160;Boost.Anyhttps://www.boost.org/doc/libs/1_59_0/doc/any.html    Chapter&#160;3.&#160;Boost.Any           Home Libraries People FAQ More         Chapter&#160;3.&#160;Boost.Any  Kevlin Henney  Copyright &#169; 2001 Kevlin Henney  Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Examples Reference  ValueType requirements Header &lt;boost/any.hpp&gt;  Acknowledgements     Introduction There are times when a generic (in the sense of     general as opposed to     template-based programming) type is needed:     variables that are truly variable, accommodating values of many     other more specific types rather than C++'s normal strict and     static types. We can distinguish three basic kinds of generic     type:  Converting types that can hold one of a number of         possible value types, e.g. int and         string, and freely convert between them, for         instance interpreting 5 as "5" or         vice-versa.  Such types are common in scripting and other         interpreted         languages.          boost::lexical_cast         supports such conversion functionality.          Discriminated types that contain values of different types but         do not attempt conversion between them, i.e. 5 is         held strictly as an int and is not implicitly         convertible either to "5" or to         5.0. Their indifference to interpretation but         awareness of type effectively makes them safe, generic         containers of single values, with no scope for surprises from         ambiguous conversions.          Indiscriminate types that can refer to anything but are         oblivious to the actual underlying type, entrusting all forms         of access and interpretation to the programmer. This niche is         dominated by void *, which offers plenty of scope         for surprising, undefined behavior.  The boost::any class     (based on the class of the same name described in "Valued     Conversions" by Kevlin Henney, C++     Report 12(7), July/August 2000) is a variant value type     based on the second category. It supports copying of any value     type and safe checked extraction of that value strictly against     its type. A similar design, offering more appropriate operators,     can be used for a generalized function adaptor,     any_function, a generalized iterator adaptor,     any_iterator, and other object types that need     uniform runtime treatment but support only compile-time template     parameter conformance.             
Chapter&#160;4.&#160;Boost.Arrayhttps://www.boost.org/doc/libs/1_59_0/doc/array.html    Chapter&#160;4.&#160;Boost.Array           Home Libraries People FAQ More         Chapter&#160;4.&#160;Boost.Array  Nicolai Josuttis  Copyright &#169; 2001-2004 Nicolai M. Josuttis  Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Reference Header &lt;boost/array.hpp&gt; Design Rationale For more information... Acknowledgements     Introduction The C++ Standard Template Library STL as part of the C++     Standard Library provides a framework for processing algorithms on     different kind of containers. However, ordinary arrays don't     provide the interface of STL containers (although, they provide     the iterator interface of STL containers). As replacement for ordinary arrays, the STL provides class     std::vector.  However,     std::vector&lt;&gt; provides     the semantics of dynamic arrays. Thus, it manages data to be able     to change the number of elements. This results in some overhead in     case only arrays with static size are needed. In his book, Generic Programming and the     STL, Matthew H. Austern introduces a useful wrapper     class for ordinary arrays with static size, called     block.  It is safer and has no worse performance than     ordinary arrays. In The C++ Programming     Language, 3rd edition, Bjarne Stroustrup introduces a     similar class, called c_array, which I (Nicolai Josuttis) present     slightly modified in my book The C++ Standard Library -     A Tutorial and Reference, called     carray. This is the essence of these approaches     spiced with many feedback from boost. After considering different names, we decided to name this     class simply array. Note that this class is suggested to be part of the next     Technical Report, which will extend the C++ Standard (see     http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1548.htm). Update: std::array is (as of C++11) part of the C++ standard.     The differences between boost::array and std::array are minimal.     If you are using C++11, you should consider using std::array instead of boost::array.      Class array fulfills most     but not all of the requirements of "reversible containers" (see     Section 23.1, [lib.container.requirements] of the C++     Standard). The reasons array is not an reversible STL container is     because:         No constructors are provided. Elements may have an undetermined initial value (see the section called &#8220;Design Rationale&#8221;).  swap() has no constant complexity.  size() is always constant, based on the second template argument of the type. The container provides no allocator support.        It doesn't fulfill the requirements of a "sequence" (see Section 23.1.1, [lib.sequence.reqmts] of the C++ Standard), except that:          front() and back() are provided.  operator[] and at() are provided.                    
Redirect to generated documentationhttps://www.boost.org/doc/libs/1_59_0/doc/Assignable.html               Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at       http://www.boost.org/LICENSE_1_0.txt) -->     Redirect to generated documentation                Automatic redirection failed, please go to     http://www.boost.org/doc/libs/master/doc/html/Assignable.html     
Chapter&#160;5.&#160;Boost.Atomichttps://www.boost.org/doc/libs/1_59_0/doc/atomic.html    Chapter&#160;5.&#160;Boost.Atomic           Home Libraries People FAQ More         Chapter&#160;5.&#160;Boost.Atomic  Helge Bahmann   Andrey Semashev  Copyright &#169; 2011 Helge Bahmann Copyright &#169; 2012 Tim Blechmann Copyright &#169; 2013 Andrey Semashev           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction  Presenting       Boost.Atomic Purpose  Thread coordination using Boost.Atomic  Enforcing happens-before       through mutual exclusion happens-before       through release and acquire Fences happens-before       through release and consume Sequential consistency  Programming interfaces  Configuration and building Memory order Atomic objects Fences Feature testing macros  Usage examples  Reference       counting Spinlock Singleton with       double-checked locking pattern Wait-free       ring buffer Wait-free multi-producer       queue  Limitations Porting  Unit tests Tested compilers Acknowledgements      Introduction   Presenting       Boost.Atomic Purpose    Presenting       Boost.Atomic           Boost.Atomic is a library that provides         atomic data types and operations on these data types,         as well as memory ordering constraints required for coordinating multiple         threads through atomic variables. It implements the interface as defined         by the C++11 standard, but makes this feature available for platforms lacking         system/compiler support for this particular C++11 feature.                 Users of this library should already be familiar with concurrency in general,         as well as elementary concepts such as "mutual exclusion".                 The implementation makes use of processor-specific instructions where possible         (via inline assembler, platform libraries or compiler intrinsics), and falls         back to "emulating" atomic operations through locking.           Purpose           Operations on "ordinary" variables are not guaranteed to be atomic.         This means that with int n=0 initially, two threads concurrently         executing        void function() {   n ++; }           might result in n==1 instead of 2: Each thread will read         the old value into a processor register, increment it and write the result         back. Both threads may therefore write 1, unaware that         the other thread is doing likewise.                 Declaring atomic&lt;int&gt; n=0 instead, the same operation         on this variable will always result in n==2 as each operation         on this variable is atomic: This means that each operation         behaves as if it were strictly sequentialized with respect to the other.                 Atomic variables are useful for two purposes:                      as a means for coordinating multiple threads via custom coordination             protocols                         as faster alternatives to "locked" access to simple variables                      Take a look at the examples         section for common patterns.            Last revised: August 04, 2015 at 09:04:48 GMT         
Chapter&#160;43.&#160;Boost.Build User Manualhttps://www.boost.org/doc/libs/1_59_0/doc/bbv2.html    Chapter&#160;43.&#160;Boost.Build User Manual           Home Libraries People FAQ More        Chapter&#160;43.&#160;Boost.Build User Manual  Table of Contents  Installation Tutorial  Hello, world Properties Project Hierarchies Dependent Targets Static and shared libaries Conditions and alternatives Prebuilt targets  Overview  Concepts Boost.Jam Language Configuration Invocation Declaring Targets Projects The Build Process  Common tasks  Programs Libraries Alias Installing Testing Custom commands Precompiled Headers Generated headers Cross-compilation  Reference  General information Builtin rules Builtin features Builtin tools Builtin modules Builtin classes Build process Definitions  Extender Manual  Introduction Example: 1-to-1 generator Target types Tools and generators Features Main target rules Toolset modules  Frequently Asked Questions         How do I get the current value of feature in Jamfile?             I am getting a "Duplicate name of actual target" error. What does that       mean?             Accessing environment variables             How to control properties order?             How to control the library linking order on Unix?             Can I get capture external program output using a Boost.Jam variable?             How to get the project root (a.k.a. Jamroot) location?             How to change compilation flags for one file?             Why are the dll-path and hardcode-dll-paths        properties useful?      Targets in site-config.jam Header-only libraries          What is the difference between Boost.Build,          b2, bjam and Perforce Jam?             Installation        To install Boost.Build from an official release or a nightly build, as       available on the official web site,       follow these steps:                  Unpack the release. On the command line, go to the root of the           unpacked tree.                     Run either .\bootstrap.bat (on Windows), or           ./bootstrap.sh (on other operating systems).                     Run            ./b2 install --prefix=PREFIX           where PREFIX is a directory where you           want Boost.Build to be installed.                     Optionally, add PREFIX/bin           to your PATH environment variable.           If you are not using a Boost.Build package, but rather the version     bundled with the Boost C++ Libraries, the above commands should be run     in the tools/build/v2 directory.        Now that Boost.Build is installed, you can try some of the examples. Copy       PREFIX/share/boost-build/examples/hello       to a different directory, then change to that directory and run:  PREFIX/bin/b2        A simple executable should be built.                  
Macro BOOST_ACCUMULATORS_DEFINE_EXTRACTORhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_ACCUMULATORS_DEFINE_EXTRACTOR.html    Macro BOOST_ACCUMULATORS_DEFINE_EXTRACTOR           Home Libraries People FAQ More         Macro BOOST_ACCUMULATORS_DEFINE_EXTRACTOR BOOST_ACCUMULATORS_DEFINE_EXTRACTOR  Synopsis // In header: &lt;boost/accumulators/framework/extractor.hpp&gt;  BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(Tag, Feature, ParamSeq)    Copyright &#169; 2005, 2006 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_ACCUMULATORS_GCC_VERSIONhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_ACCUMULATORS_GCC_VERSION.html    Macro BOOST_ACCUMULATORS_GCC_VERSION           Home Libraries People FAQ More         Macro BOOST_ACCUMULATORS_GCC_VERSION BOOST_ACCUMULATORS_GCC_VERSION  Synopsis // In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;  BOOST_ACCUMULATORS_GCC_VERSION    Copyright &#169; 2005, 2006 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_ACCUMULATORS_IGNORE_GLOBALhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_ACCUMULATORS_IGNORE_GLOBAL.html    Macro BOOST_ACCUMULATORS_IGNORE_GLOBAL           Home Libraries People FAQ More         Macro BOOST_ACCUMULATORS_IGNORE_GLOBAL BOOST_ACCUMULATORS_IGNORE_GLOBAL  Synopsis // In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;  BOOST_ACCUMULATORS_IGNORE_GLOBAL(X)    Copyright &#169; 2005, 2006 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_ACCUMULATORS_MAX_ARGShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_ACCUMULATORS_MAX_ARGS.html    Macro BOOST_ACCUMULATORS_MAX_ARGS           Home Libraries People FAQ More         Macro BOOST_ACCUMULATORS_MAX_ARGS BOOST_ACCUMULATORS_MAX_ARGS  Synopsis // In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;  BOOST_ACCUMULATORS_MAX_ARGS  Description The maximum number of arguments that may be specified to an accumulator_set's accumulation function. Defaults to 15.      Copyright &#169; 2005, 2006 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_ACCUMULATORS_MAX_FEATUREShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_ACCUMULATORS_MAX_FEATURES.html    Macro BOOST_ACCUMULATORS_MAX_FEATURES           Home Libraries People FAQ More         Macro BOOST_ACCUMULATORS_MAX_FEATURES BOOST_ACCUMULATORS_MAX_FEATURES  Synopsis // In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;  BOOST_ACCUMULATORS_MAX_FEATURES  Description The maximum number of accumulators that may be put in an accumulator_set. Defaults to BOOST_MPL_LIMIT_VECTOR_SIZE (which defaults to 20).      Copyright &#169; 2005, 2006 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONSThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST.html    Macro BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST           Home Libraries People FAQ More         Macro BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST  Synopsis // In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;  BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST(T)    Copyright &#169; 2005, 2006 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Boost.Asiohttps://www.boost.org/doc/libs/1_59_0/doc/boost_asio.html   Boost.Asio         Home Libraries People FAQ More       Boost.Asio  Christopher Kohlhoff  Copyright &#169; 2003-2015 Christopher M.       Kohlhoff           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)               Boost.Asio is a cross-platform C++ library for network and low-level I/O programming     that provides developers with a consistent asynchronous model using a modern     C++ approach.        Overview             An overview of the features included in Boost.Asio, plus rationale and           design information.           Using Boost.Asio             How to use Boost.Asio in your applications. Includes information on library           dependencies and supported platforms.           Tutorial             A tutorial that introduces the fundamental concepts required to use Boost.Asio,           and shows how to use Boost.Asio to develop simple client and server programs.           Examples             Examples that illustrate the use of Boost.Asio in more complex applications.           Reference             Detailed class and function reference.           Revision History             Log of Boost.Asio changes made in each Boost release.           Index             Book-style text index of Boost.Asio documentation.              Last revised: August 04, 2015 at 09:34:09 GMT       
Macro BOOST_CB_ASSERThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_CB_ASSERT.html    Macro BOOST_CB_ASSERT           Home Libraries People FAQ More         Macro BOOST_CB_ASSERT BOOST_CB_ASSERT  Synopsis // In header: &lt;boost/circular_buffer.hpp&gt;  BOOST_CB_ASSERT(Expr)    Copyright &#169; 2003-2013 Jan Gaspar         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_CB_ASSERT_TEMPLATED_ITERATOR_CONSTRUCTORShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_CB_ASSERT_TEMPLATED_ITERATOR_CONSTRUCTORS.html    Macro BOOST_CB_ASSERT_TEMPLATED_ITERATOR_CONSTRUCTORS           Home Libraries People FAQ More         Macro BOOST_CB_ASSERT_TEMPLATED_ITERATOR_CONSTRUCTORS BOOST_CB_ASSERT_TEMPLATED_ITERATOR_CONSTRUCTORS  Synopsis // In header: &lt;boost/circular_buffer.hpp&gt;  BOOST_CB_ASSERT_TEMPLATED_ITERATOR_CONSTRUCTORS    Copyright &#169; 2003-2013 Jan Gaspar         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_CB_ENABLE_DEBUGhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_CB_ENABLE_DEBUG.html    Macro BOOST_CB_ENABLE_DEBUG           Home Libraries People FAQ More         Macro BOOST_CB_ENABLE_DEBUG BOOST_CB_ENABLE_DEBUG  Synopsis // In header: &lt;boost/circular_buffer.hpp&gt;  BOOST_CB_ENABLE_DEBUG    Copyright &#169; 2003-2013 Jan Gaspar         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_CB_IS_CONVERTIBLEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_CB_IS_CONVERTIBLE.html    Macro BOOST_CB_IS_CONVERTIBLE           Home Libraries People FAQ More         Macro BOOST_CB_IS_CONVERTIBLE BOOST_CB_IS_CONVERTIBLE  Synopsis // In header: &lt;boost/circular_buffer.hpp&gt;  BOOST_CB_IS_CONVERTIBLE(Iterator, Type)    Copyright &#169; 2003-2013 Jan Gaspar         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Boost.Circular_buffer C++ Referencehttps://www.boost.org/doc/libs/1_59_0/doc/boost_circular_buffer_c___reference.html    Boost.Circular_buffer C++ Reference           Home Libraries People FAQ More        Boost.Circular_buffer C++ Reference  Header &lt;boost/circular_buffer.hpp&gt; Header &lt;boost/circular_buffer/base.hpp&gt; Header &lt;boost/circular_buffer/debug.hpp&gt; Header &lt;boost/circular_buffer/details.hpp&gt; Header &lt;boost/circular_buffer/space_optimized.hpp&gt;    Header &lt;boost/circular_buffer.hpp&gt;   BOOST_CB_ENABLE_DEBUG BOOST_CB_ASSERT(Expr) BOOST_CB_IS_CONVERTIBLE(Iterator, Type) BOOST_CB_ASSERT_TEMPLATED_ITERATOR_CONSTRUCTORS    Header &lt;boost/circular_buffer/base.hpp&gt; namespace boost {   template&lt;typename T, typename Alloc&gt; class circular_buffer;   template&lt;typename T, typename Alloc&gt;      bool operator==(const circular_buffer&lt; T, Alloc &gt; &amp;,                      const circular_buffer&lt; T, Alloc &gt; &amp;);   template&lt;typename T, typename Alloc&gt;      bool operator&lt;(const circular_buffer&lt; T, Alloc &gt; &amp;,                     const circular_buffer&lt; T, Alloc &gt; &amp;);   template&lt;typename T, typename Alloc&gt;      bool operator!=(const circular_buffer&lt; T, Alloc &gt; &amp;,                      const circular_buffer&lt; T, Alloc &gt; &amp;);   template&lt;typename T, typename Alloc&gt;      bool operator&gt;(const circular_buffer&lt; T, Alloc &gt; &amp;,                     const circular_buffer&lt; T, Alloc &gt; &amp;);   template&lt;typename T, typename Alloc&gt;      bool operator&lt;=(const circular_buffer&lt; T, Alloc &gt; &amp;,                      const circular_buffer&lt; T, Alloc &gt; &amp;);   template&lt;typename T, typename Alloc&gt;      bool operator&gt;=(const circular_buffer&lt; T, Alloc &gt; &amp;,                      const circular_buffer&lt; T, Alloc &gt; &amp;);   template&lt;typename T, typename Alloc&gt;      void swap(circular_buffer&lt; T, Alloc &gt; &amp;, circular_buffer&lt; T, Alloc &gt; &amp;); }   Header &lt;boost/circular_buffer/debug.hpp&gt;  Header &lt;boost/circular_buffer/details.hpp&gt;   Header &lt;boost/circular_buffer/space_optimized.hpp&gt; namespace boost {   template&lt;typename T, typename Alloc&gt; class circular_buffer_space_optimized;    // Test two space optimized circular buffers for equality.    template&lt;typename T, typename Alloc&gt;      bool operator==(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs,                      const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);    // Lexicographical comparison.    template&lt;typename T, typename Alloc&gt;      bool operator&lt;(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs,                     const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);    // Test two space optimized circular buffers for non-equality.    template&lt;typename T, typename Alloc&gt;      bool operator!=(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs,                      const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);    // Lexicographical comparison.    template&lt;typename T, typename Alloc&gt;      bool operator&gt;(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs,                     const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);    // Lexicographical comparison.    template&lt;typename T, typename Alloc&gt;      bool operator&lt;=(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs,                      const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);    // Lexicographical comparison.    template&lt;typename T, typename Alloc&gt;      bool operator&gt;=(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs,                      const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);    // Swap the contents of two space optimized circular buffers.    template&lt;typename T, typename Alloc&gt;      void swap(circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs,                circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs); }     Copyright &#169; 2003-2013 Jan Gaspar         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Boost.Container Header Referencehttps://www.boost.org/doc/libs/1_59_0/doc/boost_container_header_reference.html    Boost.Container Header Reference           Home Libraries People FAQ More        Boost.Container Header Reference  Header &lt;boost/container/adaptive_pool.hpp&gt; Header &lt;boost/container/allocator.hpp&gt; Header &lt;boost/container/allocator_traits.hpp&gt; Header &lt;boost/container/container_fwd.hpp&gt; Header &lt;boost/container/deque.hpp&gt; Header &lt;boost/container/flat_map.hpp&gt; Header &lt;boost/container/flat_set.hpp&gt; Header &lt;boost/container/list.hpp&gt; Header &lt;boost/container/map.hpp&gt; Header &lt;boost/container/new_allocator.hpp&gt; Header &lt;boost/container/node_allocator.hpp&gt; Header &lt;boost/container/options.hpp&gt; Header &lt;boost/container/scoped_allocator.hpp&gt; Header &lt;boost/container/scoped_allocator_fwd.hpp&gt; Header &lt;boost/container/set.hpp&gt; Header &lt;boost/container/slist.hpp&gt; Header &lt;boost/container/small_vector.hpp&gt; Header &lt;boost/container/stable_vector.hpp&gt; Header &lt;boost/container/static_vector.hpp&gt; Header &lt;boost/container/string.hpp&gt; Header &lt;boost/container/throw_exception.hpp&gt; Header &lt;boost/container/vector.hpp&gt;    Header &lt;boost/container/adaptive_pool.hpp&gt; namespace boost {   namespace container {     template&lt;typename T, std::size_t NodesPerBlock = ADP_nodes_per_block,               std::size_t MaxFreeBlocks = ADP_max_free_blocks,               std::size_t OverheadPercent = ADP_overhead_percent&gt;        class adaptive_pool;   } }    Header &lt;boost/container/allocator.hpp&gt; This class is an extended STL-compatible that offers advanced allocation mechanism (in-place expansion, shrinking, burst-allocation...) This allocator is a wrapper around a modified DLmalloc.  namespace boost {   namespace container {     template&lt;typename T&gt; class allocator;   } }    Header &lt;boost/container/allocator_traits.hpp&gt; namespace boost {   namespace container {     template&lt;typename Allocator&gt; struct allocator_traits;   } }    Header &lt;boost/container/container_fwd.hpp&gt; This header file forward declares the following containers:  boost::container::vector boost::container::stable_vector boost::container::static_vector boost::container::slist boost::container::list boost::container::set boost::container::multiset boost::container::map boost::container::multimap boost::container::flat_set boost::container::flat_multiset boost::container::flat_map boost::container::flat_multimap boost::container::basic_string boost::container::string boost::container::wstring    It forward declares the following allocators:  boost::container::allocator boost::container::node_allocator boost::container::adaptive_pool    And finally it defines the following types  namespace boost {   namespace container {     struct default_init_t;     struct ordered_range_t;     struct ordered_unique_range_t;      enum tree_type_enum;     typedef implementation_defined tree_assoc_defaults;      static const ordered_range_t ordered_range;     static const ordered_unique_range_t ordered_unique_range;     static const default_init_t default_init;   } }    Header &lt;boost/container/deque.hpp&gt; namespace boost {   namespace container {     template&lt;typename T, typename Allocator = new_allocator&lt;T&gt; &gt; class deque;   } }    Header &lt;boost/container/flat_map.hpp&gt; namespace boost {   namespace container {     template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;,               typename Allocator = new_allocator&lt; std::pair&lt; Key, T&gt; &gt; &gt;        class flat_map;     template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;,               typename Allocator = new_allocator&lt; std::pair&lt; Key, T&gt; &gt; &gt;        class flat_multimap;   } }    Header &lt;boost/container/flat_set.hpp&gt; namespace boost {   namespace container {     template&lt;typename Key, typename Compare = std::less&lt;Key&gt;,               typename Allocator = new_allocator&lt;Key&gt; &gt;        class flat_multiset;     template&lt;typename Key, typename Compare = std::less&lt;Key&gt;,               typename Allocator = new_allocator&lt;Key&gt; &gt;        class flat_set;   } }    Header &lt;boost/container/list.hpp&gt; namespace boost {   namespace container {     template&lt;typename T, typename Allocator = new_allocator&lt;T&gt; &gt; class list;   } }    Header &lt;boost/container/map.hpp&gt; namespace boost {   namespace container {     template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;,               typename Allocator = new_allocator&lt; std::pair&lt; const Key, T&gt; &gt;,               typename MapOptions = tree_assoc_defaults&gt;        class map;     template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;,               typename Allocator = new_allocator&lt; std::pair&lt; const Key, T&gt; &gt;,               typename MultiMapOptions = tree_assoc_defaults&gt;        class multimap;   } }    Header &lt;boost/container/new_allocator.hpp&gt; namespace boost {   namespace container {     template&lt;typename T&gt; class new_allocator;      template&lt;&gt; class new_allocator&lt;void&gt;;      template&lt;bool Value&gt; struct new_allocator_bool;   } }    Header &lt;boost/container/node_allocator.hpp&gt; namespace boost {   namespace container {     template&lt;typename T,               std::size_t NodesPerBlock = NodeAlloc_nodes_per_block&gt;        class node_allocator;   } }    Header &lt;boost/container/options.hpp&gt; namespace boost {   namespace container {     template&lt;bool Enabled&gt; struct optimize_size;     template&lt;class... Options&gt; struct tree_assoc_options;     template&lt;tree_type_enum TreeType&gt; struct tree_type;   } }    Header &lt;boost/container/scoped_allocator.hpp&gt; namespace boost {   namespace container {     template&lt;typename T&gt; struct constructible_with_allocator_prefix;     template&lt;typename T&gt; struct constructible_with_allocator_suffix;      template&lt;typename OuterAlloc, typename... InnerAllocs&gt;        class scoped_allocator_adaptor;      template&lt;bool ZeroInner&gt; struct scoped_allocator_operator_equal;      template&lt;&gt; struct scoped_allocator_operator_equal&lt;true&gt;;      template&lt;typename T, typename Allocator&gt; struct uses_allocator;     template&lt;typename OuterA1, typename OuterA2,               BOOST_CONTAINER_SCOPEDALLOC_ALLINNERCLASS &gt;        bool operator==(const scoped_allocator_adaptor&lt; OuterA1, InnerAllocs...&gt; &amp; a,                        const scoped_allocator_adaptor&lt; OuterA2, InnerAllocs...&gt; &amp; b);     template&lt;typename OuterA1, typename OuterA2,               BOOST_CONTAINER_SCOPEDALLOC_ALLINNERCLASS &gt;        bool operator!=(const scoped_allocator_adaptor&lt; OuterA1, InnerAllocs...&gt; &amp; a,                        const scoped_allocator_adaptor&lt; OuterA2, InnerAllocs...&gt; &amp; b);   } }    Header &lt;boost/container/scoped_allocator_fwd.hpp&gt; This header file forward declares boost::container::scoped_allocator_adaptor and defines the following types:  namespace boost {   namespace container {     typedef const std::allocator_arg_t &amp; allocator_arg_t;      static allocator_arg_t allocator_arg;   } }    Header &lt;boost/container/set.hpp&gt; namespace boost {   namespace container {     template&lt;typename Key, typename Compare = std::less&lt;Key&gt;,               typename Allocator = new_allocator&lt;Key&gt;,               typename MultiSetOptions = tree_assoc_defaults&gt;        class multiset;     template&lt;typename Key, typename Compare = std::less&lt;Key&gt;,               typename Allocator = new_allocator&lt;Key&gt;,               typename SetOptions = tree_assoc_defaults&gt;        class set;   } }    Header &lt;boost/container/slist.hpp&gt; namespace boost {   namespace container {     template&lt;typename T, typename Allocator = new_allocator&lt;T&gt; &gt; class slist;   } }    Header &lt;boost/container/small_vector.hpp&gt; namespace boost {   namespace container {     template&lt;typename T, std::size_t N,               typename Allocator = new_allocator&lt;T&gt; &gt;        class small_vector;     template&lt;typename Allocator&gt; class small_vector_allocator;     template&lt;typename T, typename SecondaryAllocator&gt; class small_vector_base;   } }    Header &lt;boost/container/stable_vector.hpp&gt; namespace boost {   namespace container {     template&lt;typename T, typename Allocator = new_allocator&lt;T&gt; &gt;        class stable_vector;   } }    Header &lt;boost/container/static_vector.hpp&gt; namespace boost {   namespace container {     template&lt;typename Value, std::size_t Capacity&gt; class static_vector;     template&lt;typename V, std::size_t C1, std::size_t C2&gt;        bool operator==(static_vector&lt; V, C1 &gt; const &amp;,                        static_vector&lt; V, C2 &gt; const &amp;);     template&lt;typename V, std::size_t C1, std::size_t C2&gt;        bool operator!=(static_vector&lt; V, C1 &gt; const &amp;,                        static_vector&lt; V, C2 &gt; const &amp;);     template&lt;typename V, std::size_t C1, std::size_t C2&gt;        bool operator&lt;(static_vector&lt; V, C1 &gt; const &amp;,                       static_vector&lt; V, C2 &gt; const &amp;);     template&lt;typename V, std::size_t C1, std::size_t C2&gt;        bool operator&gt;(static_vector&lt; V, C1 &gt; const &amp;,                       static_vector&lt; V, C2 &gt; const &amp;);     template&lt;typename V, std::size_t C1, std::size_t C2&gt;        bool operator&lt;=(static_vector&lt; V, C1 &gt; const &amp;,                        static_vector&lt; V, C2 &gt; const &amp;);     template&lt;typename V, std::size_t C1, std::size_t C2&gt;        bool operator&gt;=(static_vector&lt; V, C1 &gt; const &amp;,                        static_vector&lt; V, C2 &gt; const &amp;);     template&lt;typename V, std::size_t C1, std::size_t C2&gt;        void swap(static_vector&lt; V, C1 &gt; &amp;, static_vector&lt; V, C2 &gt; &amp;);   } }    Header &lt;boost/container/string.hpp&gt; namespace boost {   namespace container {     template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;,               typename Allocator = new_allocator&lt;CharT&gt; &gt;        class basic_string;     typedef basic_string&lt; char,std::char_traits&lt; char &gt;,new_allocator&lt; char &gt; &gt; string;     typedef basic_string&lt; wchar_t,std::char_traits&lt; wchar_t &gt;,new_allocator&lt; wchar_t &gt; &gt; wstring;     template&lt;typename CharT, typename Traits, typename Allocator&gt;        basic_string&lt; CharT, Traits, Allocator &gt;        operator+(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                  const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        basic_string&lt; CharT, Traits, Allocator &gt;        operator+(basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp; x,                  basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        basic_string&lt; CharT, Traits, Allocator &gt;        operator+(basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp; x,                  const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        basic_string&lt; CharT, Traits, Allocator &gt;        operator+(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                  basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        basic_string&lt; CharT, Traits, Allocator &gt;        operator+(const CharT * s, basic_string&lt; CharT, Traits, Allocator &gt; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        basic_string&lt; CharT, Traits, Allocator &gt;        operator+(basic_string&lt; CharT, Traits, Allocator &gt; x, const CharT * s);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        basic_string&lt; CharT, Traits, Allocator &gt;        operator+(CharT c, basic_string&lt; CharT, Traits, Allocator &gt; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        basic_string&lt; CharT, Traits, Allocator &gt;        operator+(basic_string&lt; CharT, Traits, Allocator &gt; x, const CharT c);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator==(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                        const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator==(const CharT * s,                        const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator==(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                        const CharT * s);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator!=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                        const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator!=(const CharT * s,                        const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator!=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                        const CharT * s);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&lt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                       const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&lt;(const CharT * s,                       const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&lt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                       const CharT * s);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&gt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                       const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&gt;(const CharT * s,                       const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&gt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                       const CharT * s);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&lt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                        const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&lt;=(const CharT * s,                        const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&lt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                        const CharT * s);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&gt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                        const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&gt;=(const CharT * s,                        const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        bool operator&gt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                        const CharT * s);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        void swap(basic_string&lt; CharT, Traits, Allocator &gt; &amp; x,                  basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        std::basic_ostream&lt; CharT, Traits &gt; &amp;        operator&lt;&lt;(std::basic_ostream&lt; CharT, Traits &gt; &amp; os,                   const basic_string&lt; CharT, Traits, Allocator &gt; &amp; s);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        std::basic_istream&lt; CharT, Traits &gt; &amp;        operator&gt;&gt;(std::basic_istream&lt; CharT, Traits &gt; &amp; is,                   basic_string&lt; CharT, Traits, Allocator &gt; &amp; s);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        std::basic_istream&lt; CharT, Traits &gt; &amp;        getline(std::istream &amp; is, basic_string&lt; CharT, Traits, Allocator &gt; &amp; s,                CharT delim);     template&lt;typename CharT, typename Traits, typename Allocator&gt;        std::basic_istream&lt; CharT, Traits &gt; &amp;        getline(std::basic_istream&lt; CharT, Traits &gt; &amp; is,                basic_string&lt; CharT, Traits, Allocator &gt; &amp; s);     template&lt;typename Ch, typename Allocator&gt;        std::size_t hash_value(basic_string&lt; Ch, std::char_traits&lt; Ch &gt;, Allocator &gt; const &amp; v);   } }    Header &lt;boost/container/throw_exception.hpp&gt; namespace boost {   namespace container {     void throw_bad_alloc();     void throw_out_of_range(const char *);     void throw_length_error(const char *);     void throw_logic_error(const char *);     void throw_runtime_error(const char *);   } }    Header &lt;boost/container/vector.hpp&gt; namespace boost {   namespace container {     template&lt;typename T, typename Allocator = new_allocator&lt;T&gt; &gt; class vector;   } }     Copyright &#169; 2009-2013 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_COPY_ASSIGN_REFhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_COPY_ASSIGN_REF.html    Macro BOOST_COPY_ASSIGN_REF           Home Libraries People FAQ More         Macro BOOST_COPY_ASSIGN_REF BOOST_COPY_ASSIGN_REF  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_COPY_ASSIGN_REF(TYPE)  Description This macro is used to achieve portable syntax in copy assignment for classes marked as BOOST_COPYABLE_AND_MOVABLE.      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_COPYABLE_AND_MOVABLEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_COPYABLE_AND_MOVABLE.html    Macro BOOST_COPYABLE_AND_MOVABLE           Home Libraries People FAQ More         Macro BOOST_COPYABLE_AND_MOVABLE BOOST_COPYABLE_AND_MOVABLE  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_COPYABLE_AND_MOVABLE(TYPE)  Description This macro marks a type as copyable and movable. The user will need to write a move constructor/assignment and a copy assignment as explained in the documentation to fully write a copyable and movable class.      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_FWD_REFhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_FWD_REF.html    Macro BOOST_FWD_REF           Home Libraries People FAQ More         Macro BOOST_FWD_REF BOOST_FWD_REF  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_FWD_REF(TYPE)  Description This macro is used to implement portable perfect forwarding as explained in the documentation.      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_INTRUSIVE_OPTION_CONSTANThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_INTRUSIVE_OPTION_CONSTANT.html    Macro BOOST_INTRUSIVE_OPTION_CONSTANT           Home Libraries People FAQ More         Macro BOOST_INTRUSIVE_OPTION_CONSTANT BOOST_INTRUSIVE_OPTION_CONSTANT  Synopsis // In header: &lt;boost/intrusive/pack_options.hpp&gt;  BOOST_INTRUSIVE_OPTION_CONSTANT(OPTION_NAME, TYPE, VALUE, CONSTANT_NAME)  Description Defines an option class of name OPTION_NAME that can be used to specify a constant of type TYPE with value VALUE... struct OPTION_NAME&lt;TYPE VALUE&gt; {  unspecified_content  };  ...that after being combined with boost::intrusive::pack_options, will contain a CONSTANT_NAME static constant of value VALUE. Example: //[includes and namespaces omitted for brevity]  //This macro will create the following class: //    template&lt;bool Enabled&gt; //    struct incremental //    { unspecified_content }; BOOST_INTRUSIVE_OPTION_CONSTANT(incremental, bool, Enabled, is_incremental)  struct empty_default{};  const bool is_incremental = pack_options&lt; empty_default, incremental&lt;true&gt; &gt;::type::is_incremental;  BOOST_STATIC_ASSERT(( is_incremental == true ));        Copyright &#169; 2005 Olaf KrzikallaCopyright &#169; 2006-2015 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_INTRUSIVE_OPTION_TYPEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_INTRUSIVE_OPTION_TYPE.html    Macro BOOST_INTRUSIVE_OPTION_TYPE           Home Libraries People FAQ More         Macro BOOST_INTRUSIVE_OPTION_TYPE BOOST_INTRUSIVE_OPTION_TYPE  Synopsis // In header: &lt;boost/intrusive/pack_options.hpp&gt;  BOOST_INTRUSIVE_OPTION_TYPE(OPTION_NAME, TYPE, TYPEDEF_EXPR, TYPEDEF_NAME)  Description Defines an option class of name OPTION_NAME that can be used to specify a type of type TYPE... struct OPTION_NAME&lt;class TYPE&gt; {  unspecified_content  };  ...that after being combined with boost::intrusive::pack_options, will typedef TYPE as a typedef of name TYPEDEF_NAME. Example: //[includes and namespaces omitted for brevity]  //This macro will create the following class: //    template&lt;class VoidPointer&gt; //    struct my_pointer //    { unspecified_content }; BOOST_INTRUSIVE_OPTION_TYPE(my_pointer, VoidPointer, boost::remove_pointer&lt;VoidPointer&gt;::type, my_pointer_type)  struct empty_default{};  typedef pack_options&lt; empty_default, typename my_pointer&lt;void*&gt; &gt;::type::my_pointer_type type;  BOOST_STATIC_ASSERT(( boost::is_same&lt;type, void&gt;::value ));        Copyright &#169; 2005 Olaf KrzikallaCopyright &#169; 2006-2015 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_IS_MPI_DATATYPEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_IS_MPI_DATATYPE.html    Macro BOOST_IS_MPI_DATATYPE           Home Libraries People FAQ More         Macro BOOST_IS_MPI_DATATYPE BOOST_IS_MPI_DATATYPE  Synopsis // In header: &lt;boost/mpi/datatype.hpp&gt;  BOOST_IS_MPI_DATATYPE(T)    Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )                
Chapter&#160;17.&#160;Boost.Lexical_Cast 1.0https://www.boost.org/doc/libs/1_59_0/doc/boost_lexical_cast.html    Chapter&#160;17.&#160;Boost.Lexical_Cast 1.0           Home Libraries People FAQ More         Chapter&#160;17.&#160;Boost.Lexical_Cast 1.0 Copyright &#169; 2000-2005 Kevlin Henney Copyright &#169; 2006-2010 Alexander Nasonov Copyright &#169; 2011-2014 Antony       Polukhin           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Motivation Examples  Strings       to numbers conversion Numbers       to strings conversion Converting       to string without dynamic memory allocation Converting       part of the string Generic       programming (Boost.Fusion) Generic       programming (Boost.Variant)  Synopsis  lexical_cast bad_lexical_cast try_lexical_convert  Frequently     Asked Questions Changes Performance  Tests       description Clang       version 3.0 (tags/RELEASE_30/final) GNU       C++ version 4.6.3 GNU       C++ version 4.5.3 GNU       C++ version 4.4.7 Microsoft       Visual C++ version 11.0      Motivation         Sometimes a value must be converted to a literal text form, such as an int represented as a std::string,       or vice-versa, when a std::string is interpreted as an int. Such examples are common when converting       between data types internal to a program and representation external to a program,       such as windows and configuration files.             The standard C and C++ libraries offer a number of facilities for performing       such conversions. However, they vary with their ease of use, extensibility,       and safety.             For instance, there are a number of limitations with the family of standard       C functions typified by atoi:                  Conversion is supported in one direction only: from text to internal data           type. Converting the other way using the C library requires either the           inconvenience and compromised safety of the sprintf           function, or the loss of portability associated with non-standard functions           such as itoa.                     The range of types supported is only a subset of the built-in numeric types,           namely int, long, and double.                     The range of types cannot be extended in a uniform manner. For instance,           conversion from string representation to complex or rational.                  The standard C functions typified by strtol       have the same basic limitations, but offer finer control over the conversion       process. However, for the common case such control is often either not required       or not used. The scanf family       of functions offer even greater control, but also lack safety and ease of use.             The standard C++ library offers stringstream       for the kind of in-core formatting being discussed. It offers a great deal       of control over the formatting and conversion of I/O to and from arbitrary       types through text. However, for simple conversions direct use of stringstream can be either clumsy (with the       introduction of extra local variables and the loss of infix-expression convenience)       or obscure (where stringstream       objects are created as temporary objects in an expression). Facets provide       a comprehensive concept and facility for controlling textual representation,       but their perceived complexity and high entry level requires an extreme degree       of involvement for simple conversions, and excludes all but a few programmers.             The lexical_cast function template       offers a convenient and consistent form for supporting common conversions to       and from arbitrary types when they are represented as text. The simplification       it offers is in expression-level convenience for such conversions. For more       involved conversions, such as where precision or formatting need tighter control       than is offered by the default behavior of lexical_cast,       the conventional std::stringstream approach is recommended. Where       the conversions are numeric to numeric, boost::numeric_cast       may offer more reasonable behavior than lexical_cast.             For a good discussion of the options and issues involved in string-based formatting,       including comparison of stringstream,       lexical_cast, and others, see       Herb Sutter's article, The       String Formatters of Manor Farm. Also, take a look at the Performance       section.         Last revised: August 04, 2015 at 09:06:45 GMT         
Macro BOOST_MOVABLE_BUT_NOT_COPYABLEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MOVABLE_BUT_NOT_COPYABLE.html    Macro BOOST_MOVABLE_BUT_NOT_COPYABLE           Home Libraries People FAQ More         Macro BOOST_MOVABLE_BUT_NOT_COPYABLE BOOST_MOVABLE_BUT_NOT_COPYABLE  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_MOVABLE_BUT_NOT_COPYABLE(TYPE)  Description This macro marks a type as movable but not copyable, disabling copy construction and assignment. The user will need to write a move constructor/assignment as explained in the documentation to fully write a movable but not copyable class.      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_MOVE_BASEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MOVE_BASE.html    Macro BOOST_MOVE_BASE           Home Libraries People FAQ More         Macro BOOST_MOVE_BASE BOOST_MOVE_BASE &#8212; defined(BOOST_MOVE_MSVC_AUTO_MOVE_RETURN_BUG) || defined(BOOST_MOVE_DOXYGEN_INVOKED)   Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_MOVE_BASE(BASE_TYPE, ARG)  Description This macro is used to achieve portable optimal move constructors. When implementing the move constructor, in C++03 compilers the moved-from argument must be cast to the base type before calling boost::move() due to rvalue reference limitations. In C++11 compilers the cast from a rvalue reference of a derived type to a rvalue reference of a base type is implicit.      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_MOVE_IMPL_NO_COPY_CTOR_OR_ASSIGNhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MOVE_IMPL_NO_COPY_CTOR_OR_ASSIGN.html    Macro BOOST_MOVE_IMPL_NO_COPY_CTOR_OR_ASSIGN           Home Libraries People FAQ More         Macro BOOST_MOVE_IMPL_NO_COPY_CTOR_OR_ASSIGN BOOST_MOVE_IMPL_NO_COPY_CTOR_OR_ASSIGN  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_MOVE_IMPL_NO_COPY_CTOR_OR_ASSIGN(TYPE)    Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_MOVE_REThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MOVE_RET.html    Macro BOOST_MOVE_RET           Home Libraries People FAQ More         Macro BOOST_MOVE_RET BOOST_MOVE_RET  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_MOVE_RET(RET_TYPE, REF)  Description This macro is used to achieve portable move return semantics. The C++11 Standard allows implicit move returns when the object to be returned is designated by a lvalue and:  The criteria for elision of a copy operation are met OR The criteria would be met save for the fact that the source object is a function parameter    For C++11 conforming compilers this macros only yields to REF: return BOOST_MOVE_RET(RET_TYPE, REF); -&gt; return REF; For compilers without rvalue references this macro does an explicit move if the move emulation is activated and the return type (RET_TYPE) is not a reference. For non-conforming compilers with rvalue references like Visual 2010 &amp; 2012, an explicit move is performed if RET_TYPE is not a reference. Caution: When using this macro in non-conforming or C++03 compilers, a move will be performed even if the C++11 standard does not allow it (e.g. returning a static variable). The user is responsible for using this macro only to return local objects that met C++11 criteria.      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_MPI_BCAST_BOTTOM_WORKS_FINEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MPI_BCAST_BOTTOM_WORKS_FINE.html    Macro BOOST_MPI_BCAST_BOTTOM_WORKS_FINE           Home Libraries People FAQ More         Macro BOOST_MPI_BCAST_BOTTOM_WORKS_FINE BOOST_MPI_BCAST_BOTTOM_WORKS_FINE &#8212; Indicates that MPI_Bcast supports MPI_BOTTOM.   Synopsis // In header: &lt;boost/mpi/config.hpp&gt;  BOOST_MPI_BCAST_BOTTOM_WORKS_FINE  Description Some implementations have a broken MPI_Bcast wrt to MPI_BOTTOM. BullX MPI and LAM seems to be among them, at least for some versions. The broacast_test.cpp test test_skeleton_and_content can be used to detect that.      Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )                
Macro BOOST_MPI_CALLING_CONVENTIONhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MPI_CALLING_CONVENTION.html    Macro BOOST_MPI_CALLING_CONVENTION           Home Libraries People FAQ More         Macro BOOST_MPI_CALLING_CONVENTION BOOST_MPI_CALLING_CONVENTION &#8212; Specifies the calling convention that will be used for callbacks from the underlying C MPI.   Synopsis // In header: &lt;boost/mpi/config.hpp&gt;  BOOST_MPI_CALLING_CONVENTION  Description This is a Windows-specific macro, which will be used internally to state the calling convention of any function that is to be used as a callback from MPI. For example, the internally-defined functions that are used in a call to MPI_Op_create. This macro is likely only to be useful to users that wish to bypass Boost.MPI, registering their own callbacks in certain cases, e.g., through MPI_Op_create.      Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )                
Macro BOOST_MPI_CHECK_RESULThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MPI_CHECK_RESULT.html    Macro BOOST_MPI_CHECK_RESULT           Home Libraries People FAQ More         Macro BOOST_MPI_CHECK_RESULT BOOST_MPI_CHECK_RESULT  Synopsis // In header: &lt;boost/mpi/exception.hpp&gt;  BOOST_MPI_CHECK_RESULT(MPIFunc, Args)  Description Call the MPI routine MPIFunc with arguments Args (surrounded by parentheses). If the result is not MPI_SUCCESS, use boost::throw_exception to throw an exception or abort, depending on BOOST_NO_EXCEPTIONS.      Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )                
Macro BOOST_MPI_DECLhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MPI_DECL.html    Macro BOOST_MPI_DECL           Home Libraries People FAQ More         Macro BOOST_MPI_DECL BOOST_MPI_DECL  Synopsis // In header: &lt;boost/mpi/config.hpp&gt;  BOOST_MPI_DECL    Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )                
Macro BOOST_MPI_HAS_MEMORY_ALLOCATIONhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MPI_HAS_MEMORY_ALLOCATION.html    Macro BOOST_MPI_HAS_MEMORY_ALLOCATION           Home Libraries People FAQ More         Macro BOOST_MPI_HAS_MEMORY_ALLOCATION BOOST_MPI_HAS_MEMORY_ALLOCATION &#8212; Determine if the MPI implementation has support for memory allocation.   Synopsis // In header: &lt;boost/mpi/config.hpp&gt;  BOOST_MPI_HAS_MEMORY_ALLOCATION  Description This macro will be defined when the underlying MPI implementation has support for the MPI-2 memory allocation routines MPI_Alloc_mem and MPI_Free_mem. When defined, the allocator class template will provide Standard Library-compliant access to these memory-allocation routines.      Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )                
Macro BOOST_MPI_HAS_NOARG_INITIALIZATIONhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MPI_HAS_NOARG_INITIALIZATION.html    Macro BOOST_MPI_HAS_NOARG_INITIALIZATION           Home Libraries People FAQ More         Macro BOOST_MPI_HAS_NOARG_INITIALIZATION BOOST_MPI_HAS_NOARG_INITIALIZATION &#8212; Determine if the MPI implementation has supports initialization without command-line arguments.   Synopsis // In header: &lt;boost/mpi/config.hpp&gt;  BOOST_MPI_HAS_NOARG_INITIALIZATION  Description This macro will be defined when the underlying implementation supports initialization of MPI without passing along command-line arguments, e.g., MPI_Init(NULL, NULL). When defined, the environment class will provide a default constructor. This macro is always defined for MPI-2 implementations.      Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )                
Macro BOOST_MPI_HOMOGENEOUShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_MPI_HOMOGENEOUS.html    Macro BOOST_MPI_HOMOGENEOUS           Home Libraries People FAQ More         Macro BOOST_MPI_HOMOGENEOUS BOOST_MPI_HOMOGENEOUS &#8212; Comment this macro is you are running in an heterogeneous environement.   Synopsis // In header: &lt;boost/mpi/config.hpp&gt;  BOOST_MPI_HOMOGENEOUS  Description When this flags is enabled, we assume some simple, POD like, type can be transmited without paying the cost of portable serialization. Comment this if your platform is not homogeneous and that portable serialization/deserialization must be performed. It you do so, check that you MPI implementation supports thats kind of environement.      Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )                
Macro BOOST_PARAMETER_NESTED_KEYWORDhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PARAMETER_NESTED_KEYWORD.html    Macro BOOST_PARAMETER_NESTED_KEYWORD           Home Libraries People FAQ More         Macro BOOST_PARAMETER_NESTED_KEYWORD BOOST_PARAMETER_NESTED_KEYWORD  Synopsis // In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;  BOOST_PARAMETER_NESTED_KEYWORD(tag_namespace, name, alias)    Copyright &#169; 2005, 2006 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROGRAM_OPTIONS_DECLhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROGRAM_OPTIONS_DECL.html    Macro BOOST_PROGRAM_OPTIONS_DECL           Home Libraries People FAQ More         Macro BOOST_PROGRAM_OPTIONS_DECL BOOST_PROGRAM_OPTIONS_DECL  Synopsis // In header: &lt;boost/program_options/config.hpp&gt;  BOOST_PROGRAM_OPTIONS_DECL    Copyright &#169; 2002-2004 Vladimir PrusDistributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROGRAM_OPTIONS_VERSIONhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROGRAM_OPTIONS_VERSION.html    Macro BOOST_PROGRAM_OPTIONS_VERSION           Home Libraries People FAQ More         Macro BOOST_PROGRAM_OPTIONS_VERSION BOOST_PROGRAM_OPTIONS_VERSION  Synopsis // In header: &lt;boost/program_options/version.hpp&gt;  BOOST_PROGRAM_OPTIONS_VERSION  Description The version of the source interface. The value will be incremented whenever a change is made which might cause compilation errors for existing code.      Copyright &#169; 2002-2004 Vladimir PrusDistributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_A_consthttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_A_const.html    Macro BOOST_PROTO_A_const           Home Libraries People FAQ More         Macro BOOST_PROTO_A_const BOOST_PROTO_A_const &#8212;        Generates sequences like                A0 const,         A1 const, &#8230;         AN-1 const       .       Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_A_const(N)  Description          Intended for use with the BOOST_PROTO_REPEAT()         and BOOST_PROTO_LOCAL_ITERATE() macros.                 BOOST_PROTO_A_const(N) generates sequences like:                  A0 const, A1 const, &#8230; AN-1 const             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_A_const_refhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_A_const_ref.html    Macro BOOST_PROTO_A_const_ref           Home Libraries People FAQ More         Macro BOOST_PROTO_A_const_ref BOOST_PROTO_A_const_ref &#8212;        Generates sequences like                A0 const &amp;,         A1 const &amp;, &#8230;         AN-1 const &amp;       .       Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_A_const_ref(N)  Description          Intended for use with the BOOST_PROTO_REPEAT()         and BOOST_PROTO_LOCAL_ITERATE() macros.                 BOOST_PROTO_A_const_ref(N) generates sequences like:                  A0 const &amp;, A1 const &amp;, &#8230; AN-1 const &amp;             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_A_const_ref_ahttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_A_const_ref_a.html    Macro BOOST_PROTO_A_const_ref_a           Home Libraries People FAQ More         Macro BOOST_PROTO_A_const_ref_a BOOST_PROTO_A_const_ref_a &#8212;        Generates sequences like                 A0 const &amp; a0,         A1 const &amp; a1, &#8230;         AN-1 const &amp; aN-1       .       Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_A_const_ref_a(N)  Description          Intended for use with the BOOST_PROTO_REPEAT()         and BOOST_PROTO_LOCAL_ITERATE() macros.                 BOOST_PROTO_A_const_ref_a(N) generates sequences like:                  A0 const &amp; a0, A1 const &amp; a1, &#8230; AN-1 const &amp; aN-1             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_Ahttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_A_idp208416528.html    Macro BOOST_PROTO_A           Home Libraries People FAQ More         Macro BOOST_PROTO_A BOOST_PROTO_A &#8212;        Generates sequences like                 A0,         A1, &#8230;         AN-1       .       Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_A(N)  Description          Intended for use with the BOOST_PROTO_REPEAT()         and BOOST_PROTO_LOCAL_ITERATE() macros.                 BOOST_PROTO_A(N) generates sequences like:                  A0, A1, &#8230; AN-1             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_ahttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_a_idp208469408.html    Macro BOOST_PROTO_a           Home Libraries People FAQ More         Macro BOOST_PROTO_a BOOST_PROTO_a &#8212;        Generates sequences like                 a0,         a1, &#8230;         aN-1       .       Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_a(N)  Description          Intended for use with the BOOST_PROTO_REPEAT()         and BOOST_PROTO_LOCAL_ITERATE() macros.                 BOOST_PROTO_a(N) generates sequences like:                  a0, a1, &#8230; aN-1             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_A_refhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_A_ref.html    Macro BOOST_PROTO_A_ref           Home Libraries People FAQ More         Macro BOOST_PROTO_A_ref BOOST_PROTO_A_ref &#8212;        Generates sequences like                A0 &amp;,         A1 &amp;, &#8230;         AN-1 &amp;       .       Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_A_ref(N)  Description          Intended for use with the BOOST_PROTO_REPEAT()         and BOOST_PROTO_LOCAL_ITERATE() macros.                 BOOST_PROTO_A_ref(N) generates sequences like:                  A0 &amp;, A1 &amp;, &#8230; AN-1 &amp;             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_A_ref_ahttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_A_ref_a.html    Macro BOOST_PROTO_A_ref_a           Home Libraries People FAQ More         Macro BOOST_PROTO_A_ref_a BOOST_PROTO_A_ref_a &#8212;        Generates sequences like                A0 &amp; a0,         A1 &amp; a1, &#8230;         AN-1 &amp; aN-1       .       Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_A_ref_a(N)  Description          Intended for use with the BOOST_PROTO_REPEAT()         and BOOST_PROTO_LOCAL_ITERATE() macros.                 BOOST_PROTO_A_ref_a(N) generates sequences like:                  A0 &amp; a0, A1 &amp; a1, &#8230; AN-1 &amp; aN-1             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_ASSERT_MATCHEShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_ASSERT_MATCHES.html    Macro BOOST_PROTO_ASSERT_MATCHES           Home Libraries People FAQ More         Macro BOOST_PROTO_ASSERT_MATCHES BOOST_PROTO_ASSERT_MATCHES &#8212;        Assert at compile time that a particular expression       matches the specified grammar.       Synopsis // In header: &lt;boost/proto/debug.hpp&gt;  BOOST_PROTO_ASSERT_MATCHES(expr, Grammar)  Description          Use BOOST_PROTO_ASSERT_MATCHES() to assert at compile-time that         an expression matches a grammar.                 Example: typedef proto::plus&lt; proto::terminal&lt; int &gt;, proto::terminal&lt; int &gt; &gt; PlusInts;  BOOST_PROTO_ASSERT_MATCHES( proto::lit(1) + 42, PlusInts );                  See also:           proto::assert_matches() proto::assert_matches_not() BOOST_PROTO_ASSERT_MATCHES_NOT()              Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_ASSERT_MATCHES_NOThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_ASSERT_MATCHES_NOT.html    Macro BOOST_PROTO_ASSERT_MATCHES_NOT           Home Libraries People FAQ More         Macro BOOST_PROTO_ASSERT_MATCHES_NOT BOOST_PROTO_ASSERT_MATCHES_NOT &#8212;        Assert at compile time that a particular expression       does not match the specified grammar.       Synopsis // In header: &lt;boost/proto/debug.hpp&gt;  BOOST_PROTO_ASSERT_MATCHES_NOT(expr, Grammar)  Description          Use BOOST_PROTO_ASSERT_MATCHES_NOT() to assert at compile-time that         an expression does not match a grammar.                  Example: typedef proto::plus&lt; proto::terminal&lt; int &gt;, proto::terminal&lt; int &gt; &gt; PlusInts;  BOOST_PROTO_ASSERT_MATCHES_NOT( proto::lit("a string") + 42, PlusInts );                  See also:           proto::assert_matches() proto::assert_matches_not() BOOST_PROTO_ASSERT_MATCHES()              Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_AUTOhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_AUTO.html    Macro BOOST_PROTO_AUTO           Home Libraries People FAQ More         Macro BOOST_PROTO_AUTO BOOST_PROTO_AUTO &#8212; For defining a local variable that stores a Proto expression template,       deep-copying the expression so there are no dangling references.  Synopsis // In header: &lt;boost/proto/proto_typeof.hpp&gt;  BOOST_PROTO_AUTO(Var, Expr)  Description          To define a local variable ex that stores the expression         proto::lit(1) + 2,         do the following: BOOST_PROTO_AUTO( ex, proto::lit(1) + 2 ); .         The above is equivalent to the following:          BOOST_AUTO( ex, proto::deep_copy( proto::lit(1) + 2 ) );             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_BASIC_EXTENDShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_BASIC_EXTENDS.html    Macro BOOST_PROTO_BASIC_EXTENDS           Home Libraries People FAQ More         Macro BOOST_PROTO_BASIC_EXTENDS BOOST_PROTO_BASIC_EXTENDS &#8212; For creating expression wrappers that add members to a Proto expression template, like       proto::extends&lt;&gt;,       but while retaining POD-ness of the expression wrapper.  Synopsis // In header: &lt;boost/proto/extends.hpp&gt;  BOOST_PROTO_BASIC_EXTENDS(Expr, Derived, Domain)  Description          BOOST_PROTO_BASIC_EXTENDS() adds the basic typedefs, member functions, and         data members necessary to make a struct a valid Proto expression extension. It does not         add any constructors, virtual functions or access control blocks that would render the containing         struct non-POD.                 Expr is the Proto expression that the enclosing struct extends.         Derived is the type of the enclosing struct.         Domain is the Proto domain to which this expression extension belongs.         (See proto::domain&lt;&gt;.)         Can be preceeded with "typename" if the specified domain is a dependent type.        BOOST_PROTO_BASIC_EXTENDS() adds to its enclosing struct         exactly one data member of type Expr.         If the Domain parameter is dependent, you can specify it as         typename Domain, as in         BOOST_PROTO_BASIC_EXTENDS(Expr, Derived, typename Domain)                 Example: template&lt; class Expr &gt; struct my_expr;  struct my_domain   : proto::domain&lt; proto::pod_generator&lt; my_expr &gt; &gt; {};  template&lt; class Expr &gt; struct my_expr {     // OK, this makes my_expr&lt;&gt; a valid Proto expression extension.     // my_expr&lt;&gt; does /not/ have overloaded assignment, subscript,     // and function call operators that build expression templates, however.     BOOST_PROTO_BASIC_EXTENDS(Expr, my_expr, my_domain) };  // OK, my_expr&lt;&gt; is POD, so this is statically initialized: my_expr&lt; proto::terminal&lt;int&gt;::type &gt; const _1 = {{1}};                  See also:           BOOST_PROTO_EXTENDS_ASSIGN() BOOST_PROTO_EXTENDS_SUBSCRIPT() BOOST_PROTO_EXTENDS_FUNCTION() BOOST_PROTO_EXTENDS()              Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_DEFINE_ENV_VARhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_DEFINE_ENV_VAR.html    Macro BOOST_PROTO_DEFINE_ENV_VAR           Home Libraries People FAQ More         Macro BOOST_PROTO_DEFINE_ENV_VAR BOOST_PROTO_DEFINE_ENV_VAR &#8212;        Define a type and a global variable of that type that can be used       to initialize a slot in a Proto transform environment.       Synopsis // In header: &lt;boost/proto/transform/env.hpp&gt;  BOOST_PROTO_DEFINE_ENV_VAR(Type, Name)  Description          Proto primitive transforms can optionally accept an environment in         their third parameter which is a key/value store of environment         variables. Use the BOOST_PROTO_DEFINE_ENV_VAR() macro         to define the keys.                 See the description for proto::data_type         for an example of the class interface created by this macro.                 Example:                  BOOST_PROTO_DEFINE_ENV_VAR(mykey_type, mykey);  struct FetchMyKey   : proto::when&lt; _, proto::_env_var&lt;mykey_type&gt; &gt; {};  int main() {     proto::terminal&lt;int&gt;::type i = {42};     char const * sz = FetchMyKey()(i, 0, (mykey = "hello!"));     assert(0 == std::strcmp(sz, "hello!"); }             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_DEFINE_OPERATORShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_DEFINE_OPERATORS.html    Macro BOOST_PROTO_DEFINE_OPERATORS           Home Libraries People FAQ More         Macro BOOST_PROTO_DEFINE_OPERATORS BOOST_PROTO_DEFINE_OPERATORS &#8212; Defines a complete set of expression template-building operator overloads for use       with non-Proto terminal types.  Synopsis // In header: &lt;boost/proto/operators.hpp&gt;  BOOST_PROTO_DEFINE_OPERATORS(Trait, Domain)  Description          With BOOST_PROTO_DEFINE_OPERATORS(), it is possible to         non-intrusively adapt an existing (non-Proto) type to be a Proto terminal.                  Trait is the name of a unary Boolean metafunction that returns         true for any types you would like to treat as Proto terminals.                 Domain is the name of the Proto domain associated with         these new Proto terminals. You may use         proto::default_domain         for the Domain if you do not wish to associate these terminals         with any domain.                 Example:          namespace My {   // A non-Proto terminal type   struct S {};    // A unary Boolean metafunction that returns true for type S   template&lt;typename T&gt; struct IsS : mpl::false_ {};   template&lt;&gt; struct IsS&lt;S&gt; : mpl::true_ {};      // Make S a Proto terminal non-intrusively by defining the   // appropriate operator overloads. This should be in the same   // namespace as S so that these overloads can be found by   // argument-dependent lookup   BOOST_PROTO_DEFINE_OPERATORS(IsS, proto::default_domain) }  int main() {   My::S s1, s2;      // OK, this builds a Proto expression template:   s1 + s2;  }             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_EXTENDShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_EXTENDS.html    Macro BOOST_PROTO_EXTENDS           Home Libraries People FAQ More         Macro BOOST_PROTO_EXTENDS BOOST_PROTO_EXTENDS &#8212; For creating expression wrappers that add behaviors to a Proto expression template, like       proto::extends&lt;&gt;,       but while retaining POD-ness of the expression wrapper.  Synopsis // In header: &lt;boost/proto/extends.hpp&gt;  BOOST_PROTO_EXTENDS(Expr, Derived, Domain)  Description          Equivalent to:          BOOST_PROTO_BASIC_EXTENDS(Expr, Derived, Domain) BOOST_PROTO_EXTENDS_ASSIGN() BOOST_PROTO_EXTENDS_SUBSCRIPT() BOOST_PROTO_EXTENDS_FUNCTION()         If the Domain parameter is dependent, you can specify it as         typename Domain, as in         BOOST_PROTO_EXTENDS(Expr, Derived, typename Domain)                 Example: template&lt; class Expr &gt; struct my_expr;  struct my_domain   : proto::domain&lt; proto::pod_generator&lt; my_expr &gt; &gt; {};  template&lt; class Expr &gt; struct my_expr {     // OK, this makes my_expr&lt;&gt; a valid Proto expression extension.     // my_expr&lt;&gt; has overloaded assignment, subscript,     // and function call operators that build expression templates.     BOOST_PROTO_EXTENDS(Expr, my_expr, my_domain) };  // OK, my_expr&lt;&gt; is POD, so this is statically initialized: my_expr&lt; proto::terminal&lt;int&gt;::type &gt; const _1 = {{1}};             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_EXTENDS_ASSIGNhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_EXTENDS_ASSIGN.html    Macro BOOST_PROTO_EXTENDS_ASSIGN           Home Libraries People FAQ More         Macro BOOST_PROTO_EXTENDS_ASSIGN BOOST_PROTO_EXTENDS_ASSIGN &#8212; For adding to an expression extension class an overloaded assignment operator that       builds an expression template.  Synopsis // In header: &lt;boost/proto/extends.hpp&gt;  BOOST_PROTO_EXTENDS_ASSIGN()  Description          Use BOOST_PROTO_EXTENDS_ASSIGN() after          BOOST_PROTO_BASIC_EXTENDS() to give an expression         extension class an overloaded assignment operator that builds an expression template.                 See also:           BOOST_PROTO_BASIC_EXTENDS() BOOST_PROTO_EXTENDS_SUBSCRIPT() BOOST_PROTO_EXTENDS_FUNCTION() BOOST_PROTO_EXTENDS()              Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_EXTENDS_FUNCTIONhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_EXTENDS_FUNCTION.html    Macro BOOST_PROTO_EXTENDS_FUNCTION           Home Libraries People FAQ More         Macro BOOST_PROTO_EXTENDS_FUNCTION BOOST_PROTO_EXTENDS_FUNCTION &#8212; For adding to an expression extension class a set of overloaded function call operators       that build expression templates.  Synopsis // In header: &lt;boost/proto/extends.hpp&gt;  BOOST_PROTO_EXTENDS_FUNCTION()  Description          Use BOOST_PROTO_EXTENDS_FUNCTION() after          BOOST_PROTO_BASIC_EXTENDS() to give an expression         extension class a set of overloaded function call operators that build expression templates.         In addition, BOOST_PROTO_EXTENDS_FUNCTION() adds a nested         result&lt;&gt; class template that is a metafunction for         calculating the return type of the overloaded function call operators.                 See also:           BOOST_PROTO_BASIC_EXTENDS() BOOST_PROTO_EXTENDS_ASSIGN() BOOST_PROTO_EXTENDS_SUBSCRIPT() BOOST_PROTO_EXTENDS()              Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_EXTENDS_SUBSCRIPThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_EXTENDS_SUBSCRIPT.html    Macro BOOST_PROTO_EXTENDS_SUBSCRIPT           Home Libraries People FAQ More         Macro BOOST_PROTO_EXTENDS_SUBSCRIPT BOOST_PROTO_EXTENDS_SUBSCRIPT &#8212; For adding to an expression extension class an overloaded subscript operator that       builds an expression template.  Synopsis // In header: &lt;boost/proto/extends.hpp&gt;  BOOST_PROTO_EXTENDS_SUBSCRIPT()  Description          Use BOOST_PROTO_EXTENDS_SUBSCRIPT() after          BOOST_PROTO_BASIC_EXTENDS() to give an expression         extension class an overloaded subscript operator that builds an expression template.                 See also:           BOOST_PROTO_BASIC_EXTENDS() BOOST_PROTO_EXTENDS_ASSIGN() BOOST_PROTO_EXTENDS_FUNCTION() BOOST_PROTO_EXTENDS()              Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_EXTENDS_USING_ASSIGNhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_EXTENDS_USING_ASSIGN.html    Macro BOOST_PROTO_EXTENDS_USING_ASSIGN           Home Libraries People FAQ More         Macro BOOST_PROTO_EXTENDS_USING_ASSIGN BOOST_PROTO_EXTENDS_USING_ASSIGN &#8212; For exposing in classes that inherit from       proto::extends&lt;&gt;       the overloaded assignment operators defined therein.  Synopsis // In header: &lt;boost/proto/extends.hpp&gt;  BOOST_PROTO_EXTENDS_USING_ASSIGN(Derived)  Description          The standard usage of         proto::extends&lt;&gt;         is to inherit from it. However, the derived class automatically gets a compiler-generated assignment         operator that will hide the ones defined in         proto::extends&lt;&gt;.         Use BOOST_PROTO_EXTENDS_USING_ASSIGN() in the derived class to unhide the assignment         operators defined in         proto::extends&lt;&gt;.                 See proto::extends&lt;&gt;         for an example that demonstrates usage of BOOST_PROTO_EXTENDS_USING_ASSIGN().            Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT.html    Macro BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT           Home Libraries People FAQ More         Macro BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT &#8212; For exposing in classes that inherit from       proto::extends&lt;&gt;       the overloaded assignment operators defined therein. Unlike the       BOOST_PROTO_EXTENDS_USING_ASSIGN() macro,       BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT() is for use in non-dependent       contexts.         Synopsis // In header: &lt;boost/proto/extends.hpp&gt;  BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT(Derived)  Description          The standard usage of         proto::extends&lt;&gt;         is to define a class template that inherits from it. The derived class template automatically gets a         compiler-generated assignment operator that hides the ones defined in         proto::extends&lt;&gt;.         Using BOOST_PROTO_EXTENDS_USING_ASSIGN() in the derived class solves this problem.                 However, if the expression extension is an ordinary class and not a class template, the usage of         BOOST_PROTO_EXTENDS_USING_ASSIGN() is in a so-called non-dependent context. In plain English,         it means it is illegal to use typename in some places where it is required in a class template.          In those cases, you should use BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT() instead.         		See also: 		  proto::extends&lt;&gt; BOOST_PROTO_EXTENDS_USING_ASSIGN()              Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_FUSION_V2https://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_FUSION_V2.html    Macro BOOST_PROTO_FUSION_V2           Home Libraries People FAQ More         Macro BOOST_PROTO_FUSION_V2 BOOST_PROTO_FUSION_V2  Synopsis // In header: &lt;boost/xpressive/xpressive_fwd.hpp&gt;  BOOST_PROTO_FUSION_V2    Copyright &#169; 2007 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_LOCAL_ITERATEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_LOCAL_ITERATE.html    Macro BOOST_PROTO_LOCAL_ITERATE           Home Libraries People FAQ More         Macro BOOST_PROTO_LOCAL_ITERATE BOOST_PROTO_LOCAL_ITERATE &#8212; Vertical repetition of a user-supplied macro.  Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_LOCAL_ITERATE()  Description          BOOST_PROTO_LOCAL_ITERATE() is used generate the kind of repetitive code that is typical         of EDSLs built with Proto. This macro causes the user-defined macro BOOST_PROTO_LOCAL_MACRO() to         be expanded with values in the range specified by BOOST_PROTO_LOCAL_LIMITS.                 Usage:                  #include BOOST_PROTO_LOCAL_ITERATE()                  Example:                  // Generate BOOST_PROTO_MAX_ARITY-1 overloads of the // following construct() function template. #define BOOST_PROTO_LOCAL_MACRO(N, typename_A, A_const_ref, A_const_ref_a, ref_a)\ template&lt;typename T, typename_A(N)&gt;                               \ typename proto::result_of::make_expr&lt;                             \     proto::tag::function                                          \   , construct_helper&lt;T&gt;                                           \   , A_const_ref(N)                                                \ &gt;::type const                                                     \ construct(A_const_ref_a(N))                                       \ {                                                                 \     return proto::make_expr&lt;                                      \         proto::tag::function                                      \     &gt;(                                                            \         construct_helper&lt;T&gt;()                                     \       , ref_a(N)                                                  \     );                                                            \ } #define BOOST_PROTO_LOCAL_LIMITS (1, BOOST_PP_DEC(BOOST_PROTO_MAX_ARITY)) #include BOOST_PROTO_LOCAL_ITERATE()                  The above inclusion of BOOST_PROTO_LOCAL_ITERATE()         will generate the following code:                  template&lt;typename T, typename A0&gt; typename proto::result_of::make_expr&lt;     proto::tag::function   , construct_helper&lt;T&gt;   , A0 const &amp; &gt;::type const construct(A0 const &amp; a0) {     return proto::make_expr&lt;         proto::tag::function     &gt;(         construct_helper&lt;T&gt;()       , boost::ref(a0)     ); }  template&lt;typename T, typename A0, typename A1&gt; typename proto::result_of::make_expr&lt;     proto::tag::function   , construct_helper&lt;T&gt;   , A0 const &amp;   , A1 const &amp; &gt;::type const construct(A0 const &amp; a0, A1 const &amp; a1) {     return proto::make_expr&lt;         proto::tag::function     &gt;(         construct_helper&lt;T&gt;()       , boost::ref(a0)       , boost::ref(a1)     ); }  // ... and so on, up to BOOST_PROTO_MAX_ARITY-1 arguments ...                  If BOOST_PROTO_LOCAL_LIMITS is not defined by the user, it defaults         to (1, BOOST_PROTO_MAX_ARITY).                 At each iteration, BOOST_PROTO_LOCAL_MACRO() is invoked with the current         iteration number and the following 4 macro parameters:           BOOST_PROTO_LOCAL_typename_A BOOST_PROTO_LOCAL_A BOOST_PROTO_LOCAL_A_a BOOST_PROTO_LOCAL_a           If these macros are not defined by the user, they default respectively to:           BOOST_PROTO_typename_A BOOST_PROTO_A_const_ref BOOST_PROTO_A_const_ref_a BOOST_PROTO_ref_a                   After including BOOST_PROTO_LOCAL_ITERATE(), the         following macros are automatically undefined:           BOOST_PROTO_LOCAL_MACRO BOOST_PROTO_LOCAL_LIMITS BOOST_PROTO_LOCAL_typename_A BOOST_PROTO_LOCAL_A BOOST_PROTO_LOCAL_A_a BOOST_PROTO_LOCAL_a              Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_MAX_ARITYhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_MAX_ARITY.html    Macro BOOST_PROTO_MAX_ARITY           Home Libraries People FAQ More         Macro BOOST_PROTO_MAX_ARITY BOOST_PROTO_MAX_ARITY &#8212; Controls the maximum number of child nodes an expression may have.  Synopsis // In header: &lt;boost/proto/proto_fwd.hpp&gt;  BOOST_PROTO_MAX_ARITY  Description          BOOST_PROTO_MAX_ARITY defaults to 10. It may be set higher or lower, but not         lower than 3. Setting it higher will have a negative effect on compile times.                  See also BOOST_PROTO_MAX_FUNCTION_CALL_ARITY.            Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_MAX_FUNCTION_CALL_ARITYhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_MAX_FUNCTION_CALL_ARITY.html    Macro BOOST_PROTO_MAX_FUNCTION_CALL_ARITY           Home Libraries People FAQ More         Macro BOOST_PROTO_MAX_FUNCTION_CALL_ARITY BOOST_PROTO_MAX_FUNCTION_CALL_ARITY &#8212; Controls the maximum number of arguments that operator() overloads       accept.  Synopsis // In header: &lt;boost/proto/proto_fwd.hpp&gt;  BOOST_PROTO_MAX_FUNCTION_CALL_ARITY  Description          When setting                    BOOST_PROTO_MAX_ARITY          higher than the default, compile times         slow down considerably. That is due in large part to the explosion in the number of         operator() overloads that must be generated for each         Proto expression type. By setting BOOST_PROTO_MAX_FUNCTION_CALL_ARITY         lower than BOOST_PROTO_MAX_ARITY,         compile times can be sped up considerably.            Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_MAX_LOGICAL_ARITYhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_MAX_LOGICAL_ARITY.html    Macro BOOST_PROTO_MAX_LOGICAL_ARITY           Home Libraries People FAQ More         Macro BOOST_PROTO_MAX_LOGICAL_ARITY BOOST_PROTO_MAX_LOGICAL_ARITY &#8212; Controls the maximum number of sub-grammars that            proto::or_&lt;&gt;      and                proto::and_&lt;&gt;        accept.  Synopsis // In header: &lt;boost/proto/proto_fwd.hpp&gt;  BOOST_PROTO_MAX_LOGICAL_ARITY  Description          BOOST_PROTO_MAX_LOGICAL_ARITY defaults to 10. It may be set higher or lower. Setting         it higher will have a negative effect on compile times.            Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_ref_ahttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_ref_a.html    Macro BOOST_PROTO_ref_a           Home Libraries People FAQ More         Macro BOOST_PROTO_ref_a BOOST_PROTO_ref_a &#8212;        Generates sequences like                 boost::ref(a0),         boost::ref(a1), &#8230;         boost::ref(aN-1)       .       Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_ref_a(N)  Description          Intended for use with the BOOST_PROTO_REPEAT()         and BOOST_PROTO_LOCAL_ITERATE() macros.                 BOOST_PROTO_ref_a(N) generates sequences like:                  boost::ref(a0), boost::ref(a1), &#8230; boost::ref(aN-1)             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_REPEAThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_REPEAT.html    Macro BOOST_PROTO_REPEAT           Home Libraries People FAQ More         Macro BOOST_PROTO_REPEAT BOOST_PROTO_REPEAT &#8212; Repeatedly invoke the specified macro.  Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_REPEAT(MACRO)  Description          BOOST_PROTO_REPEAT() is used to generate the kind of repetitive         code that is typical of EDSLs built with Proto.         BOOST_PROTO_REPEAT(MACRO)         is equivalent to:                  MACRO(1, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a) MACRO(2, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a) ... MACRO(BOOST_PROTO_MAX_ARITY, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)                  Example:                 See BOOST_PROTO_REPEAT_FROM_TO().            Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_REPEAT_EXhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_REPEAT_EX.html    Macro BOOST_PROTO_REPEAT_EX           Home Libraries People FAQ More         Macro BOOST_PROTO_REPEAT_EX BOOST_PROTO_REPEAT_EX &#8212; Repeatedly invoke the specified macro.  Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_REPEAT_EX(MACRO, typename_A, A, A_a, a)  Description          BOOST_PROTO_REPEAT_EX() is used to generate the kind of repetitive         code that is typical of EDSLs built with Proto.         BOOST_PROTO_REPEAT_EX(MACRO, typename_A, A, A_a, a)         is equivalent to:                  MACRO(1, typename_A, A, A_a, a) MACRO(2, typename_A, A, A_a, a) ... MACRO(BOOST_PROTO_MAX_ARITY, typename_A, A, A_a, a)                  Example:                 See BOOST_PROTO_REPEAT_FROM_TO().            Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_REPEAT_FROM_TOhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_REPEAT_FROM_TO.html    Macro BOOST_PROTO_REPEAT_FROM_TO           Home Libraries People FAQ More         Macro BOOST_PROTO_REPEAT_FROM_TO BOOST_PROTO_REPEAT_FROM_TO &#8212; Repeatedly invoke the specified macro.  Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_REPEAT_FROM_TO(FROM, TO, MACRO)  Description          BOOST_PROTO_REPEAT_FROM_TO() is used to generate the kind of repetitive         code that is typical of EDSLs built with Proto.         BOOST_PROTO_REPEAT_FROM_TO(FROM, TO, MACRO)         is equivalent to:                  MACRO(FROM, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a) MACRO(FROM+1, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a) ... MACRO(TO-1, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)                  Example:                  // Generate BOOST_PROTO_MAX_ARITY-1 overloads of the // following construct() function template. #define M0(N, typename_A, A_const_ref, A_const_ref_a, ref_a)      \ template&lt;typename T, typename_A(N)&gt;                               \ typename proto::result_of::make_expr&lt;                             \     proto::tag::function                                          \   , construct_helper&lt;T&gt;                                           \   , A_const_ref(N)                                                \ &gt;::type const                                                     \ construct(A_const_ref_a(N))                                       \ {                                                                 \     return proto::make_expr&lt;                                      \         proto::tag::function                                      \     &gt;(                                                            \         construct_helper&lt;T&gt;()                                     \       , ref_a(N)                                                  \     );                                                            \ } BOOST_PROTO_REPEAT_FROM_TO(1, BOOST_PROTO_MAX_ARITY, M0) #undef M0                  The above invocation of BOOST_PROTO_REPEAT_FROM_TO()         will generate the following code:                  template&lt;typename T, typename A0&gt; typename proto::result_of::make_expr&lt;     proto::tag::function   , construct_helper&lt;T&gt;   , A0 const &amp; &gt;::type const construct(A0 const &amp; a0) {     return proto::make_expr&lt;         proto::tag::function     &gt;(         construct_helper&lt;T&gt;()       , boost::ref(a0)     ); }  template&lt;typename T, typename A0, typename A1&gt; typename proto::result_of::make_expr&lt;     proto::tag::function   , construct_helper&lt;T&gt;   , A0 const &amp;   , A1 const &amp; &gt;::type const construct(A0 const &amp; a0, A1 const &amp; a1) {     return proto::make_expr&lt;         proto::tag::function     &gt;(         construct_helper&lt;T&gt;()       , boost::ref(a0)       , boost::ref(a1)     ); }  // ... and so on, up to BOOST_PROTO_MAX_ARITY-1 arguments ...             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_REPEAT_FROM_TO_EXhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_REPEAT_FROM_TO_EX.html    Macro BOOST_PROTO_REPEAT_FROM_TO_EX           Home Libraries People FAQ More         Macro BOOST_PROTO_REPEAT_FROM_TO_EX BOOST_PROTO_REPEAT_FROM_TO_EX &#8212; Repeatedly invoke the specified macro.  Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_REPEAT_FROM_TO_EX(FROM, TO, MACRO, typename_A, A, A_a, a)  Description          BOOST_PROTO_REPEAT_FROM_TO_EX() is used to generate the kind of repetitive         code that is typical of EDSLs built with Proto.         BOOST_PROTO_REPEAT_FROM_TO_EX(FROM, TO, MACRO, typename_A, A, A_a, a)         is equivalent to:                  MACRO(FROM, typename_A, A, A_a, a) MACRO(FROM+1, typename_A, A, A_a, a) ... MACRO(TO-1, typename_A, A, A_a, a)                  Example:                 See BOOST_PROTO_REPEAT_FROM_TO().            Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_PROTO_typename_Ahttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_PROTO_typename_A.html    Macro BOOST_PROTO_typename_A           Home Libraries People FAQ More         Macro BOOST_PROTO_typename_A BOOST_PROTO_typename_A &#8212;        Generates sequences like                typename A0,         typename A1, &#8230;         typename AN-1       .       Synopsis // In header: &lt;boost/proto/repeat.hpp&gt;  BOOST_PROTO_typename_A(N)  Description          Intended for use with the BOOST_PROTO_REPEAT()         and BOOST_PROTO_LOCAL_ITERATE() macros.                 BOOST_PROTO_typename_A(N) generates sequences like:                  typename A0, typename A1, &#8230; typename AN-1             Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Chapter&#160;24.&#160;Boost.Randomhttps://www.boost.org/doc/libs/1_59_0/doc/boost_random.html    Chapter&#160;24.&#160;Boost.Random           Home Libraries People FAQ More         Chapter&#160;24.&#160;Boost.Random  Jens Maurer  Copyright &#169; 2000-2005 Jens Maurer Copyright &#169; 2009, 2010 Steven Watanabe           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Tutorial  Generating       integers in a range Generating       integers with different probabilities Generating       a random password  Reference  Concepts Generators Distributions Headers  Performance History and     Acknowledgements     Introduction         Random numbers are useful in a variety of applications. The Boost Random Number       Library (Boost.Random for short) provides a variety of generators       and distributions       to produce random numbers having useful properties, such as uniform distribution.             You should read the concepts       documentation for an introduction and the definition of the basic concepts.       For a quick start, it may be sufficient to have a look at random_demo.cpp.             For a very quick start, here's an example:      boost::random::mt19937 rng;         // produces randomness out of thin air                                     // see pseudo-random number generators boost::random::uniform_int_distribution&lt;&gt; six(1,6);                                     // distribution that maps to 1..6                                     // see random number distributions int x = six(rng);                   // simulate rolling a die     Last revised: August 04, 2015 at 09:07:21 GMT         
Macro BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLDhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD.html    Macro BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD           Home Libraries People FAQ More         Macro BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD  Synopsis // In header: &lt;boost/random/mersenne_twister.hpp&gt;  BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD    Copyright &#169; 2000-2005 Jens MaurerCopyright &#169; 2009, 2010 Steven Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_RV_REFhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_RV_REF.html    Macro BOOST_RV_REF           Home Libraries People FAQ More         Macro BOOST_RV_REF BOOST_RV_REF  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_RV_REF(TYPE)  Description This macro is used to achieve portable syntax in move constructors and assignments for classes marked as BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_RV_REF_BEGhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_RV_REF_BEG.html    Macro BOOST_RV_REF_BEG           Home Libraries People FAQ More         Macro BOOST_RV_REF_BEG BOOST_RV_REF_BEG  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_RV_REF_BEG  Description This macro is used to achieve portable syntax in move constructors and assignments for template classes marked as BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE. As macros have problems with comma-separated template arguments, the template argument must be preceded with BOOST_RV_REF_BEG and ended with BOOST_RV_REF_END      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_RV_REF_BEG_IF_CXX11https://www.boost.org/doc/libs/1_59_0/doc/BOOST_RV_REF_BEG_IF_CXX11.html    Macro BOOST_RV_REF_BEG_IF_CXX11           Home Libraries People FAQ More         Macro BOOST_RV_REF_BEG_IF_CXX11 BOOST_RV_REF_BEG_IF_CXX11  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_RV_REF_BEG_IF_CXX11  Description This macro expands to BOOST_RV_REF_BEG if BOOST_NO_CXX11_RVALUE_REFERENCES is not defined, empty otherwise      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_RV_REF_ENDhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_RV_REF_END.html    Macro BOOST_RV_REF_END           Home Libraries People FAQ More         Macro BOOST_RV_REF_END BOOST_RV_REF_END  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_RV_REF_END  Description This macro is used to achieve portable syntax in move constructors and assignments for template classes marked as BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE. As macros have problems with comma-separated template arguments, the template argument must be preceded with BOOST_RV_REF_BEG and ended with BOOST_RV_REF_END      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_RV_REF_END_IF_CXX11https://www.boost.org/doc/libs/1_59_0/doc/BOOST_RV_REF_END_IF_CXX11.html    Macro BOOST_RV_REF_END_IF_CXX11           Home Libraries People FAQ More         Macro BOOST_RV_REF_END_IF_CXX11 BOOST_RV_REF_END_IF_CXX11  Synopsis // In header: &lt;boost/move/core.hpp&gt;  BOOST_RV_REF_END_IF_CXX11  Description This macro expands to BOOST_RV_REF_END if BOOST_NO_CXX11_RVALUE_REFERENCES is not defined, empty otherwise      Copyright &#169; 2008-2014 Ion Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Function BOOST_SERIALIZATION_SPLIT_FREEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_SERIALIZ_idp53472720.html    Function BOOST_SERIALIZATION_SPLIT_FREE           Home Libraries People FAQ More         Function BOOST_SERIALIZATION_SPLIT_FREE BOOST_SERIALIZATION_SPLIT_FREE  Synopsis // In header: &lt;boost/date_time/posix_time/time_serialize.hpp&gt;    BOOST_SERIALIZATION_SPLIT_FREE(boost::posix_time::ptime);  Description time_duration objects are broken down into 4 parts for serialization: types are hour_type, min_type, sec_type, and fractional_seconds_type as defined in the time_duration class      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function BOOST_SERIALIZATION_SPLIT_FREEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_SERIALIZ_idp99564336.html    Function BOOST_SERIALIZATION_SPLIT_FREE           Home Libraries People FAQ More         Function BOOST_SERIALIZATION_SPLIT_FREE BOOST_SERIALIZATION_SPLIT_FREE  Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;    BOOST_SERIALIZATION_SPLIT_FREE(::boost::gregorian::date_duration);  Description Method that does serialization for gregorian::date &lt;ndash&gt;&lt;/ndash&gt; splits to load/save      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Chapter&#160;28.&#160;Boost.StaticAsserthttps://www.boost.org/doc/libs/1_59_0/doc/boost_staticassert.html    Chapter&#160;28.&#160;Boost.StaticAssert           Home Libraries People FAQ More         Chapter&#160;28.&#160;Boost.StaticAssert  John Maddock   Steve Cleary  Copyright &#169; 2000, 2005 Steve Cleary and John Maddock           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )           Table of Contents  Overview and Tutorial  Use at namespace scope. Use at function scope Use at class scope Use in templates  How it works Test Programs        This manual is also available in printer     friendly PDF format.      Overview and Tutorial  Use at namespace scope. Use at function scope Use at class scope Use in templates         The header &lt;boost/static_assert.hpp&gt;       supplies two macros:      BOOST_STATIC_ASSERT(x) BOOST_STATIC_ASSERT_MSG(x, msg)         Both generate a compile time error message if the integral-constant-expression       x is not true. In other words,       they are the compile time equivalent of the assert macro; this is sometimes       known as a "compile-time-assertion", but will be called a "static       assertion" throughout these docs. Note that if the condition is true, then the macros will generate neither       code nor data - and the macros can also be used at either namespace, class       or function scope. When used in a template, the static assertion will be evaluated       at the time the template is instantiated; this is particularly useful for validating       template parameters.             If the C++0x static_assert feature       is available, both macros will use it. For BOOST_STATIC_ASSERT(x),       the error message will be a stringized version of x.       For BOOST_STATIC_ASSERT_MSG(x,       msg),       the error message will be the msg       string.             If the C++0x static_assert feature       is not available, BOOST_STATIC_ASSERT_MSG(x,       msg)       will be treated as BOOST_STATIC_ASSERT(x).             The material that follows assumes the C++0x static_assert       feature is not available.             One of the aims of BOOST_STATIC_ASSERT       is to generate readable error messages. These immediately tell the user that       a library is being used in a manner that is not supported. While error messages       obviously differ from compiler to compiler, but you should see something like:      Illegal use of STATIC_ASSERTION_FAILURE&lt;false&gt;         Which is intended to at least catch the eye!             You can use BOOST_STATIC_ASSERT       at any place where you can place a declaration, that is at class, function       or namespace scope, this is illustrated by the following examples:        Use at namespace scope.          The macro can be used at namespace scope, if there is some requirement must         always be true; generally this means some platform specific requirement.         Suppose we require that int         be at least a 32-bit integral type, and that wchar_t         be an unsigned type. We can verify this at compile time as follows:        #include &lt;climits&gt; #include &lt;cwchar&gt; #include &lt;limits&gt; #include &lt;boost/static_assert.hpp&gt;  namespace my_conditions {     BOOST_STATIC_ASSERT(std::numeric_limits&lt;int&gt;::digits &gt;= 32);    BOOST_STATIC_ASSERT(WCHAR_MIN &gt;= 0);  } // namespace my_conditions           The use of the namespace my_conditions here requires some comment. The macro         BOOST_STATIC_ASSERT works         by generating an typedef declaration, and since the typedef must have a name,         the macro generates one automatically by mangling a stub name with the value         of __LINE__. When BOOST_STATIC_ASSERT is used at either class         or function scope then each use of BOOST_STATIC_ASSERT         is guaranteed to produce a name unique to that scope (provided you only use         the macro once on each line). However when used in a header at namespace         scope, that namespace can be continued over multiple headers, each of which         may have their own static assertions, and on the "same" lines,         thereby generating duplicate declarations. In theory the compiler should         silently ignore duplicate typedef declarations, however many do not do so         (and even if they do they are entitled to emit warnings in such cases). To         avoid potential problems, if you use BOOST_STATIC_ASSERT         in a header and at namespace scope, then enclose them in a namespace unique         to that header.           Use at function scope          The macro is typically used at function scope inside template functions,         when the template arguments need checking. Imagine that we have an iterator-based         algorithm that requires random access iterators. If the algorithm is instantiated         with iterators that do not meet our requirements then an error will be generated         eventually, but this may be nested deep inside several templates, making         it hard for the user to determine what went wrong. One option is to add a         static assertion at the top level of the template, in that case if the condition         is not met, then an error will be generated in a way that makes it reasonably         obvious to the user that the template is being misused.        #include &lt;iterator&gt; #include &lt;boost/static_assert.hpp&gt; #include &lt;boost/type_traits.hpp&gt;  template &lt;class RandomAccessIterator &gt; RandomAccessIterator foo(RandomAccessIterator from,                          RandomAccessIterator to) {    // this template can only be used with    // random access iterators...    typedef typename std::iterator_traits&lt;          RandomAccessIterator &gt;::iterator_category cat;    BOOST_STATIC_ASSERT(       (boost::is_convertible&lt;          cat,          const std::random_access_iterator_tag&amp;&gt;::value));    //    // detail goes here...    return from; }           A couple of footnotes are in order here: the extra set of parenthesis around         the assert, is to prevent the comma inside the is_convertible         template being interpreted by the preprocessor as a macro argument separator;         the target type for is_convertible         is a reference type, as some compilers have problems using is_convertible when the conversion is via         a user defined constructor (in any case there is no guarantee that the iterator         tag classes are copy-constructible).           Use at class scope          The macro is typically used inside classes that are templates. Suppose we         have a template-class that requires an unsigned integral type with at least         16-bits of precision as a template argument, we can achieve this using something         like this:        #include &lt;limits&gt; #include &lt;boost/static_assert.hpp&gt;  template &lt;class UnsignedInt&gt; class myclass { private:    BOOST_STATIC_ASSERT_MSG(std::numeric_limits&lt;UnsignedInt&gt;::is_specialized, "myclass can only be specialized for types with numeric_limits support.");    BOOST_STATIC_ASSERT_MSG(std::numeric_limits&lt;UnsignedInt&gt;::digits &gt;= 16, "Template argument UnsignedInt must have at least 16 bits precision.")    BOOST_STATIC_ASSERT_MSG(std::numeric_limits&lt;UnsignedInt&gt;::is_integer, "Template argument UnsignedInt must be an integer.");    BOOST_STATIC_ASSERT_MSG(!std::numeric_limits&lt;UnsignedInt&gt;::is_signed, "Template argument UnsignedInt must not be signed."); public:    /* details here */ };     Use in templates          Normally static assertions when used inside a class or function template,         will not be instantiated until the template in which it is used is instantiated.         However, there is one potential problem to watch out for: if the static assertion         is not dependent upon one or more template parameters, then the compiler         is permitted to evaluate the static assertion at the point it is first seen,         irrespective of whether the template is ever instantiated, for example:        template &lt;class T&gt; struct must_not_be_instantiated {    BOOST_STATIC_ASSERT(false); };           Will produce a compiler error with some compilers (for example Intel 8.1         or gcc 3.4), regardless of whether the template is ever instantiated. A workaround         in cases like this is to force the assertion to be dependent upon a template         parameter:        template &lt;class T&gt; struct must_not_be_instantiated {    // this will be triggered if this type is instantiated    BOOST_STATIC_ASSERT(sizeof(T) == 0); };               
Chapter&#160;31.&#160;Boost.TR1https://www.boost.org/doc/libs/1_59_0/doc/boost_tr1.html    Chapter&#160;31.&#160;Boost.TR1           Home Libraries People FAQ More         Chapter&#160;31.&#160;Boost.TR1  John Maddock  Copyright &#169; 2005 John Maddock           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Usage  Whether to use Your Native TR1       Library Header Include Style Writing Code  Configuration TR1 By Subject  Reference Wrappers. Smart Pointers. Class template result_of. Function template mem_fn. Function Object Binders. Polymorphic function       wrappers. Type Traits. Random Number Generators       and Distributions. Tuples. Tuple Interface to std::pair. Fixed Size Array. Hash Function Objects. Regular Expressions. Complex Number Algorithm       Overloads. Complex Number Additional       Algorithms. Unordered Associative       Set (Hash Table). Unordered Associative       Map (Hash Table). Mathematical Special       Functions. C99 Mathematical       Special Functions.  TR1 By Header  &lt;array&gt; &lt;cmath&gt; &lt;complex&gt; &lt;functional&gt; &lt;memory&gt; &lt;random&gt; &lt;regex&gt; &lt;tuple&gt; &lt;type_traits&gt; &lt;unordered_map&gt; &lt;unordered_set&gt; &lt;utility&gt;  Implementation Testing     Introduction     Important           This library is deprecated in favor of native C++11 standard library features,         as a result it receives little or no maintenance.                The TR1 library provides an implementation of the C++ Technical Report on Standard       Library Extensions. This library does not itself implement the TR1 components,       rather it's a thin wrapper that will include your standard library's TR1 implementation       (if it has one), otherwise it will include the Boost Library equivalents, and       import them into namespace std::tr1.                  
Macro BOOST_TRIBOOL_THIRD_STATEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TRIBOOL_THIRD_STATE.html    Macro BOOST_TRIBOOL_THIRD_STATE           Home Libraries People FAQ More         Macro BOOST_TRIBOOL_THIRD_STATE BOOST_TRIBOOL_THIRD_STATE &#8212; Declare a new name for the third state of a tribool.   Synopsis // In header: &lt;boost/logic/tribool.hpp&gt;  BOOST_TRIBOOL_THIRD_STATE(Name)  Description Use this macro to declare a new name for the third state of a tribool. This state can have any number of new names (in addition to indeterminate), all of which will be equivalent. The new name will be placed in the namespace in which the macro is expanded. Example: BOOST_TRIBOOL_THIRD_STATE(true_or_false) tribool x(true_or_false); // potentially set x if (true_or_false(x)) { // don't know what x is }      Copyright &#169; 2002-2004 Douglas GregorUse, modification and distribution is subject to the Boost     Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Macro BOOST_TYPE_ERASURE_FREEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_ERASURE_FREE.html    Macro BOOST_TYPE_ERASURE_FREE           Home Libraries People FAQ More         Macro BOOST_TYPE_ERASURE_FREE BOOST_TYPE_ERASURE_FREE &#8212; Defines a primitive concept for a free function.   Synopsis // In header: &lt;boost/type_erasure/free.hpp&gt;  BOOST_TYPE_ERASURE_FREE(qualified_name, function_name, N)  Description  The declaration of the concept is  template&lt;class Sig&gt; struct ::namespace1::namespace2::...::concept_name;   where Sig is a function type giving the signature of the function. This macro can only be used in the global namespace. Example: BOOST_TYPE_ERASURE_FREE((boost)(has_to_string), to_string, 1)          Parameters:        N is the number of arguments of the function.   function_name is the name of the function.    qualified_name should be a preprocessor sequence of the form (namespace1)(namespace2)...(concept_name).           Copyright &#169; 2011-2013 Steven Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_TYPE_ERASURE_MAX_ARITYhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_ERASURE_MAX_ARITY.html    Macro BOOST_TYPE_ERASURE_MAX_ARITY           Home Libraries People FAQ More         Macro BOOST_TYPE_ERASURE_MAX_ARITY BOOST_TYPE_ERASURE_MAX_ARITY  Synopsis // In header: &lt;boost/type_erasure/config.hpp&gt;  BOOST_TYPE_ERASURE_MAX_ARITY  Description The maximum number of arguments that functions in the library support.      Copyright &#169; 2011-2013 Steven Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_TYPE_ERASURE_MAX_FUNCTIONShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_ERASURE_MAX_FUNCTIONS.html    Macro BOOST_TYPE_ERASURE_MAX_FUNCTIONS           Home Libraries People FAQ More         Macro BOOST_TYPE_ERASURE_MAX_FUNCTIONS BOOST_TYPE_ERASURE_MAX_FUNCTIONS  Synopsis // In header: &lt;boost/type_erasure/config.hpp&gt;  BOOST_TYPE_ERASURE_MAX_FUNCTIONS  Description The maximum number of functions that an any can have.      Copyright &#169; 2011-2013 Steven Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_TYPE_ERASURE_MAX_TUPLE_SIZEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE.html    Macro BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE           Home Libraries People FAQ More         Macro BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE  Synopsis // In header: &lt;boost/type_erasure/config.hpp&gt;  BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE  Description The maximum number of elements in a tuple.      Copyright &#169; 2011-2013 Steven Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_TYPE_ERASURE_MEMBERhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_ERASURE_MEMBER.html    Macro BOOST_TYPE_ERASURE_MEMBER           Home Libraries People FAQ More         Macro BOOST_TYPE_ERASURE_MEMBER BOOST_TYPE_ERASURE_MEMBER &#8212; Defines a primitive concept for a member function.   Synopsis // In header: &lt;boost/type_erasure/member.hpp&gt;  BOOST_TYPE_ERASURE_MEMBER(qualified_name, member, N)  Description  The declaration of the concept is  template&lt;class Sig, class T = _self&gt; struct ::namespace1::namespace2::...::concept_name;   where Sig is a function type giving the signature of the member function, and T is the object type. T may be const-qualified for const member functions. This macro can only be used in the global namespace. Example: BOOST_TYPE_ERASURE_MEMBER((boost)(has_push_back), push_back, 1) typedef boost::has_push_back&lt;void(int), _self&gt; push_back_concept;     Note  In C++11 the argument N is ignored and may be omitted. BOOST_TYPE_ERASURE_MEMBER will always define a variadic concept.           Parameters:        N is the number of arguments of the function.   member is the name of the member function.    qualified_name should be a preprocessor sequence of the form (namespace1)(namespace2)...(concept_name).           Copyright &#169; 2011-2013 Steven Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSINGhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING.html    Macro BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING           Home Libraries People FAQ More         Macro BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING  Synopsis // In header: &lt;boost/type_index.hpp&gt;  BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING  Description This is a helper macro for making correct pretty_names() with RTTI off. BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING macro may be defined to '(begin_skip, end_skip, runtime_skip, runtime_skip_until)' with parameters for adding a support for compilers, that by default are not recognized by TypeIndex library. Example:  Imagine the situation when  boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name()    returns the following string:  "static const char *boost::detail::ctti&lt;int&gt;::n() [T = int]"    and boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name()    returns the following:  "static const char *boost::detail::ctti&lt;short&gt;::n() [T = short]"   As we may see first 39 characters are "static const char *boost::detail::ctti&lt;" and they do not depend on the type T. After first 39 characters we have a human readable type name which is duplicated at the end of a string. String always ends on ']', which consumes 1 character. Now if we define BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING to (39, 1, false, "") we'll be getting "int&gt;::n() [T = int"    for boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name() and "short&gt;::n() [T = short"    for boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name(). Now we need to take additional care of the characters that go before the last mention of our type. We'll do that by telling the macro that we need to cut off everything that goes before the "T = " including the "T = " itself: (39, 1, true, "T = ")   In case of GCC or Clang command line we need to add the following line while compiling all the sources: -DBOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING='(39, 1, true, "T = ")'    See RTTI emulation limitations for more info.      Copyright &#169; 2012-2014 Antony Polukhin         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITYhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY.html    Macro BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY           Home Libraries People FAQ More         Macro BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY  Synopsis // In header: &lt;boost/type_index.hpp&gt;  BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY  Description BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY is a helper macro that must be defined if mixing RTTI on/off modules. See Mixing sources with RTTI on and RTTI off section of documentation for more info.      Copyright &#169; 2012-2014 Antony Polukhin         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_TYPE_INDEX_FUNCTION_SIGNATUREhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_INDEX_FUNCTION_SIGNATURE.html    Macro BOOST_TYPE_INDEX_FUNCTION_SIGNATURE           Home Libraries People FAQ More         Macro BOOST_TYPE_INDEX_FUNCTION_SIGNATURE BOOST_TYPE_INDEX_FUNCTION_SIGNATURE  Synopsis // In header: &lt;boost/type_index.hpp&gt;  BOOST_TYPE_INDEX_FUNCTION_SIGNATURE  Description BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is used by boost::typeindex::ctti_type_index class to deduce the name of a type. If your compiler is not recognized by the TypeIndex library and you wish to work with boost::typeindex::ctti_type_index, you may define this macro by yourself. BOOST_TYPE_INDEX_FUNCTION_SIGNATURE must be defined to a compiler specific macro that outputs the whole function signature including template parameters. If your compiler is not recognised and BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is not defined, then a compile-time error will arise at any attempt to use boost::typeindex::ctti_type_index classes. See BOOST_TYPE_INDEX_REGISTER_CTTI_PARSING_PARAMS and BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING for an information of how to tune the implementation to make a nice pretty_name() output.      Copyright &#169; 2012-2014 Antony Polukhin         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_TYPE_INDEX_REGISTER_CLASShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_INDEX_REGISTER_CLASS.html    Macro BOOST_TYPE_INDEX_REGISTER_CLASS           Home Libraries People FAQ More         Macro BOOST_TYPE_INDEX_REGISTER_CLASS BOOST_TYPE_INDEX_REGISTER_CLASS  Synopsis // In header: &lt;boost/type_index.hpp&gt;  BOOST_TYPE_INDEX_REGISTER_CLASS  Description BOOST_TYPE_INDEX_REGISTER_CLASS is used to help to emulate RTTI. Put this macro into the public section of polymorphic class to allow runtime type detection. Depending on the typeid() availability this macro will expand to nothing or to virtual helper function virtual const type_info&amp; boost_type_info_type_id_runtime_() const noexcept. Example:  class A { public:     BOOST_TYPE_INDEX_REGISTER_CLASS     virtual ~A(){} };  struct B: public A {     BOOST_TYPE_INDEX_REGISTER_CLASS };  struct C: public B {     BOOST_TYPE_INDEX_REGISTER_CLASS };  ...  C c1; A* pc1 = &amp;c1; assert(boost::typeindex::type_id&lt;C&gt;() == boost::typeindex::type_id_runtime(*pc1));        Copyright &#169; 2012-2014 Antony Polukhin         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_TYPE_INDEX_USER_TYPEINDEXhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_TYPE_INDEX_USER_TYPEINDEX.html    Macro BOOST_TYPE_INDEX_USER_TYPEINDEX           Home Libraries People FAQ More         Macro BOOST_TYPE_INDEX_USER_TYPEINDEX BOOST_TYPE_INDEX_USER_TYPEINDEX  Synopsis // In header: &lt;boost/type_index.hpp&gt;  BOOST_TYPE_INDEX_USER_TYPEINDEX  Description BOOST_TYPE_INDEX_USER_TYPEINDEX can be defined to the path to header file with user provided implementation of type_index. See Making a custom type_index section of documentation for usage example.      Copyright &#169; 2012-2014 Antony Polukhin         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Chapter&#160;33.&#160;Boost.TypeErasurehttps://www.boost.org/doc/libs/1_59_0/doc/boost_typeerasure.html    Chapter&#160;33.&#160;Boost.TypeErasure           Home Libraries People FAQ More         Chapter&#160;33.&#160;Boost.TypeErasure  Steven Watanabe  Copyright &#169; 2011-2013 Steven Watanabe           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction How to read this documentation Basic Usage Composing Concepts Functions with Multiple Arguments Concepts in Depth  Defining Custom Concepts Overloading Concept Maps Associated Types  Using Any  Construction Conversions References Syntax Limitations  Examples  A polymorphic       range formatter A type-safe printf Boost.Function       with multiple signatures  Concept Definitions Predefined Concepts Reference  Header &lt;boost/type_erasure/any.hpp&gt; Header &lt;boost/type_erasure/any_cast.hpp&gt; Header &lt;boost/type_erasure/binding.hpp&gt; Header &lt;boost/type_erasure/binding_of.hpp&gt; Header &lt;boost/type_erasure/builtin.hpp&gt; Header &lt;boost/type_erasure/call.hpp&gt; Header &lt;boost/type_erasure/callable.hpp&gt; Header &lt;boost/type_erasure/check_match.hpp&gt; Header &lt;boost/type_erasure/concept_interface.hpp&gt; Header &lt;boost/type_erasure/concept_of.hpp&gt; Header &lt;boost/type_erasure/config.hpp&gt; Header &lt;boost/type_erasure/constructible.hpp&gt; Header &lt;boost/type_erasure/deduced.hpp&gt; Header &lt;boost/type_erasure/derived.hpp&gt; Header &lt;boost/type_erasure/exception.hpp&gt; Header &lt;boost/type_erasure/free.hpp&gt; Header &lt;boost/type_erasure/is_empty.hpp&gt; Header &lt;boost/type_erasure/is_placeholder.hpp&gt; Header &lt;boost/type_erasure/is_subconcept.hpp&gt; Header &lt;boost/type_erasure/iterator.hpp&gt; Header &lt;boost/type_erasure/member.hpp&gt; Header &lt;boost/type_erasure/operators.hpp&gt; Header &lt;boost/type_erasure/param.hpp&gt; Header &lt;boost/type_erasure/placeholder.hpp&gt; Header &lt;boost/type_erasure/placeholder_of.hpp&gt; Header &lt;boost/type_erasure/rebind_any.hpp&gt; Header &lt;boost/type_erasure/relaxed.hpp&gt; Header &lt;boost/type_erasure/require_match.hpp&gt; Header &lt;boost/type_erasure/same_type.hpp&gt; Header &lt;boost/type_erasure/static_binding.hpp&gt; Header &lt;boost/type_erasure/tuple.hpp&gt; Header &lt;boost/type_erasure/typeid_of.hpp&gt;  Rationale  Why       do I have to specify the presence of a destructor explicitly? Why       non-member functions? Why are the       placeholders called _a, _b and not _1       _2 Why not use boost::ref       for references?  Future Work Acknowledgements Related Work     Introduction         The Boost.TypeErasure library provides runtime polymorphism in C++ that is       more flexible than that provided by the core language.             C++ has two distinct kinds of polymorphism, virtual functions and templates,       each of which has its own advantages and disadvantages.                  Virtual functions are not resolved until runtime, while templates are always           resolved at compile time. If your types can vary at runtime (for example,           if they depend on user input), then static polymorphism with templates           doesn't help much.                     Virtual functions can be used with separate compilation. The body of a           template has to be available in every translation unit in which it is used,           slowing down compiles and increasing rebuilds.                     Virtual functions automatically make the requirements on the arguments           explicit. Templates are only checked when they're instantiated, requiring           extra work in testing, assertions, and documentation.                     The compiler creates a new copy of each function template every time it           is instantiated. This allows better optimization, because the compiler           knows everything statically, but it also causes a significant increase           of binary sizes.                     Templates support Value semantics. Objects that "behave like an int"           and are not shared are easier to reason about. To use virtual functions,           on the other hand, you have to use (smart) pointers or references.                     Template libraries can allow third-party types to be adapted non-intrusively           for seamless interoperability. With virtual functions, you have to create           a wrapper that inherits from the base class.                     Templates can handle constraints involving multiple types. For example,           std::for_each takes an iterator range and a function that can be called           on the elements of the range. Virtual functions aren't really able to express           such constraints.                  The Boost.TypeErasure library combines the superior abstraction capabilities       of templates, with the runtime flexibility of virtual functions.             Boost includes several special cases of this kind of polymorphism:                  boost::any for CopyConstructible types.                     boost::function for objects that can be called           like functions.                     Boost.Range provides any_iterator.                  Boost.TypeErasure generalizes this to support arbitrary requirements and provides       a predefined set of common concepts         Last revised: August 04, 2015 at 09:07:24 GMT         
Chapter&#160;34.&#160;Boost.TypeIndex 4.0https://www.boost.org/doc/libs/1_59_0/doc/boost_typeindex.html    Chapter&#160;34.&#160;Boost.TypeIndex 4.0           Home Libraries People FAQ More         Chapter&#160;34.&#160;Boost.TypeIndex 4.0 Copyright &#169; 2012-2014 Antony Polukhin           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Motivation Getting started  How to use Example       with Boost.Any Example       with Boost.Variant  Configuring and building the library How it works Examples  Getting       human readable and mangled type names Storing       information about a type in container  Getting       through the inheritance to receive a real type name  Exact       type matching: storing type with const, volatile and reference qualifiers Table       of raw_name() and pretty_name() outputs with and without RTTI   Boost.TypeIndex Header Reference  Header &lt;boost/type_index.hpp&gt; Header &lt;boost/type_index/ctti_type_index.hpp&gt; Header &lt;boost/type_index/stl_type_index.hpp&gt; Header &lt;boost/type_index/type_index_facade.hpp&gt;  Making a custom     type_index  Basics Getting       type infos at runtime Using       new type infos all around the code  Space and Performance Code bloat RTTI emulation     limitations  Define       the BOOST_TYPE_INDEX_FUNCTION_SIGNATURE macro Fixing       pretty_name() output  Mixing     sources with RTTI on and RTTI off Acknowledgements     Motivation         Sometimes getting and storing information about a type at runtime is required.       For such cases a construction like &amp;typeid(T) or C++11 class std::type_index       is usually used, which is where problems start:                  typeid(T) and           std::type_index require Run Time Type Info           (RTTI)                     some implementations of typeid(T)           erroneously do not strip const, volatile and references from type                     some compilers have bugs and do not correctly compare std::type_info           objects across shared libraries                     only a few implementations of Standard Library currently provide std::type_index                     no easy way to store type info without stripping const, volatile and references                     no nice and portable way to get human readable type names                     no way to easily make your own type info class                  Boost.TypeIndex library was designed to work around all those issues.         Note           T means type here. Think         of it as of T in template &lt;class T&gt;            Last revised: August 04, 2015 at 09:07:25 GMT         
Boost.TypeIndex Header Referencehttps://www.boost.org/doc/libs/1_59_0/doc/boost_typeindex_header_reference.html    Boost.TypeIndex Header Reference           Home Libraries People FAQ More        Boost.TypeIndex Header Reference  Header &lt;boost/type_index.hpp&gt; Header &lt;boost/type_index/ctti_type_index.hpp&gt; Header &lt;boost/type_index/stl_type_index.hpp&gt; Header &lt;boost/type_index/type_index_facade.hpp&gt;    Header &lt;boost/type_index.hpp&gt; Includes minimal set of headers required to use the Boost.TypeIndex library.  By inclusion of this file most optimal type index classes will be included and used as a boost::typeindex::type_index and boost::typeindex::type_info.    BOOST_TYPE_INDEX_REGISTER_CLASS BOOST_TYPE_INDEX_FUNCTION_SIGNATURE BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING BOOST_TYPE_INDEX_USER_TYPEINDEX BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY namespace boost {   namespace typeindex {     typedef platform_specific type_index;     typedef type_index::type_info_t type_info;     template&lt;typename T&gt; type_index type_id();     template&lt;typename T&gt; type_index type_id_with_cvr();     template&lt;typename T&gt; type_index type_id_runtime(const T &amp;);   } }    Header &lt;boost/type_index/ctti_type_index.hpp&gt; Contains boost::typeindex::ctti_type_index class.  boost::typeindex::ctti_type_index class can be used as a drop-in replacement for std::type_index. It is used in situations when typeid() method is not available or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined.  namespace boost {   namespace typeindex {     class ctti_type_index;      // Helper method for getting detail::ctti_data of a template parameter T.      template&lt;typename T&gt; unspecified ctti_construct();   } }    Header &lt;boost/type_index/stl_type_index.hpp&gt; Contains boost::typeindex::stl_type_index class.  boost::typeindex::stl_type_index class can be used as a drop-in replacement for std::type_index. It is used in situations when RTTI is enabled or typeid() method is available. When typeid() is disabled or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined boost::typeindex::ctti is usually used instead of boost::typeindex::stl_type_index.  namespace boost {   namespace typeindex {     class stl_type_index;   } }    Header &lt;boost/type_index/type_index_facade.hpp&gt; namespace boost {   template&lt;typename It&gt; std::size_t hash_range(It, It);   namespace typeindex {     template&lt;typename Derived, typename TypeInfo&gt; class type_index_facade;      // noexcept comparison operators for type_index_facade classes.      bool operator==,!=,&lt;,...(const type_index_facade &amp; lhs,                               const type_index_facade &amp; rhs);      // noexcept comparison operators for type_index_facade and it's TypeInfo classes.      bool operator==,!=,&lt;,...(const type_index_facade &amp; lhs,                               const TypeInfo &amp; rhs);      // noexcept comparison operators for type_index_facade's TypeInfo and type_index_facade classes.      bool operator==,!=,&lt;,...(const TypeInfo &amp; lhs,                               const type_index_facade &amp; rhs);      // Ostream operator that will output demangled name.      template&lt;typename CharT, typename TriatT, typename Derived,               typename TypeInfo&gt;        std::basic_ostream&lt; CharT, TriatT &gt; &amp;        operator&lt;&lt;(std::basic_ostream&lt; CharT, TriatT &gt; &amp; ostr,                   const type_index_facade&lt; Derived, TypeInfo &gt; &amp; ind);     template&lt;typename Derived, typename TypeInfo&gt;        std::size_t hash_value(const type_index_facade&lt; Derived, TypeInfo &gt; &amp;);   } }     Copyright &#169; 2012-2014 Antony Polukhin         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Chapter&#160;36.&#160;Boost.Units 1.1.0https://www.boost.org/doc/libs/1_59_0/doc/boost_units.html    Chapter&#160;36.&#160;Boost.Units 1.1.0           Home Libraries People FAQ More         Chapter&#160;36.&#160;Boost.Units 1.1.0  Matthias C. Schabel   Steven Watanabe  Copyright &#169; 2003-2008 Matthias Christian Schabel Copyright &#169; 2007-2010 Steven       Watanabe           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Quick Start Dimensional Analysis Units  Base Units Scaled Base Units Scaled Units  Quantities  Heterogeneous       Operators Conversions Construction       and Conversion of Quantities  Examples  Dimension Example Unit Example Quantity Example Kitchen Sink       Example using SI units Conversion Example User Defined Types Complex Example Performance       Example Radar Beam       Height Heterogeneous       Unit Example Absolute       and Relative Temperature Example Runtime       Conversion Factor Example Units       with Non-base Dimensions Output       for Composite Units Automatically Scaled       Units Conversion Factor Runtime Units Interoperability with Boost.Lambda  Utilities  Metaprogramming       Classes Metaprogramming       Predicates  Reference  Units Reference Dimensions Reference SI System Reference CGS System Reference Trigonometry and Angle System Reference Temperature System Reference Information System Reference Abstract System Reference Base Units       by Category Alphabetical       Listing of Base Units  Installation FAQ  How       does one distinguish between quantities that are physically different but have       the same units (such as energy and torque)? Angles are treated as       units Why are there       homogeneous systems? Aren't heterogeneous systems sufficient? Why can't       I construct a quantity directly from the value type? Why are conversions       explicit by default?  Acknowledgements Help Wanted Version Info Release Notes TODO     Introduction         The Boost.Units library is a C++ implementation of dimensional analysis in       a general and extensible manner, treating it as a generic compile-time metaprogramming       problem. With appropriate compiler optimization, no runtime execution cost       is introduced, facilitating the use of this library to provide dimension checking       in performance-critical code. Support for units and quantities (defined as       a unit and associated value) for arbitrary unit system models and arbitrary       value types is provided, as is a fine-grained general facility for unit conversions.       Complete SI and CGS unit systems are provided, along with systems for angles       measured in degrees, radians, gradians, and revolutions and systems for temperatures       measured in Kelvin, degrees Celsius and degrees Fahrenheit. The library architecture       has been designed with flexibility and extensibility in mind; demonstrations       of the ease of adding new units and unit conversions are provided in the examples.             In order to enable complex compile-time dimensional analysis calculations with       no runtime overhead, Boost.Units relies heavily on the Boost Metaprogramming Library       (MPL) and on template metaprogramming techniques, and is, as a consequence,       fairly demanding of compiler compliance to ISO standards. At present, it has       been successfully compiled and tested on the following compilers/platforms       :                  g++ 4.0.1 on Mac OSX 10.4                     Intel CC 9.1, 10.0, and 10.1 on Mac OSX 10.4                     g++ 3.4.4, 4.2.3, and 4.3.0 on Windows XP                     Microsoft Visual C++ 7.1, 8.0, and 9.0 on Windows XP                     Comeau 4.3.10.1 beta2 on Windows XP                     Metrowerks CodeWarrior 9.2 on Windows XP.                     Sun CC 5.9 on Solaris and Linux                  The following compilers/platforms are known not       to work :                  g++ 3.3.x                     Microsoft Visual C++ 6.0 on Windows XP                     Microsoft Visual C++ 7.0 on Windows XP                     Metrowerks CodeWarrior 8.0 on Windows XP.                     All versions of Borland.              Last revised: August 04, 2015 at 09:07:34 GMT         
Macro BOOST_UNITS_CHECK_HOMOGENEOUS_UNITShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS.html    Macro BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS           Home Libraries People FAQ More         Macro BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS  Synopsis // In header: &lt;boost/units/config.hpp&gt;  BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS  Description Enable checking to verify that a homogeneous system is actually capable of representing all the dimensions that it is used with. Off by default.      Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_UNITS_DEFAULT_CONVERSIONhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_DEFAULT_CONVERSION.html    Macro BOOST_UNITS_DEFAULT_CONVERSION           Home Libraries People FAQ More         Macro BOOST_UNITS_DEFAULT_CONVERSION BOOST_UNITS_DEFAULT_CONVERSION  Synopsis // In header: &lt;boost/units/conversion.hpp&gt;  BOOST_UNITS_DEFAULT_CONVERSION(Source, Dest)  Description Specifies the default conversion to be applied when no direct conversion is available. Source is a base unit. Dest is any unit with the same dimensions.      Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE.html    Macro BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE           Home Libraries People FAQ More         Macro BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE  Synopsis // In header: &lt;boost/units/conversion.hpp&gt;  BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE(Params, Source, Dest)  Description Specifies the default conversion to be applied when no direct conversion is available. Params is a PP Sequence of template arguments. Source is a base unit. Dest is any unit with the same dimensions. The source must not be a scaled base unit.      Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_UNITS_DEFINE_CONVERSION_FACTORhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_DEFINE_CONVERSION_FACTOR.html    Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR           Home Libraries People FAQ More         Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR BOOST_UNITS_DEFINE_CONVERSION_FACTOR  Synopsis // In header: &lt;boost/units/conversion.hpp&gt;  BOOST_UNITS_DEFINE_CONVERSION_FACTOR(Source, Destination, type_, value_)  Description Defines the conversion factor from a base unit to any unit or to another base unit with the correct dimensions. Uses of this macro must appear at global scope. If the destination unit is a base unit or a unit that contains only one base unit which is raised to the first power (e.g. feet-&gt;meters) the reverse (meters-&gt;feet in this example) need not be defined explicitly.      Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATEhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE.html    Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE           Home Libraries People FAQ More         Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE  Synopsis // In header: &lt;boost/units/conversion.hpp&gt;  BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE(Params, Source, Destination, type_, value_)  Description Defines the conversion factor from a base unit to any other base unit with the same dimensions. Params should be a Boost.Preprocessor Seq of template parameters, such as (class T1)(class T2) All uses of must appear at global scope. The reverse conversion will be defined automatically. This macro is a little dangerous, because, unlike the non-template form, it will silently fail if either base unit is scaled. This is probably not an issue if both the source and destination types depend on the template parameters, but be aware that a generic conversion to kilograms is not going to work.      Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_UNITS_DEFINE_CONVERSION_OFFSEThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_DEFINE_CONVERSION_OFFSET.html    Macro BOOST_UNITS_DEFINE_CONVERSION_OFFSET           Home Libraries People FAQ More         Macro BOOST_UNITS_DEFINE_CONVERSION_OFFSET BOOST_UNITS_DEFINE_CONVERSION_OFFSET  Synopsis // In header: &lt;boost/units/absolute.hpp&gt;  BOOST_UNITS_DEFINE_CONVERSION_OFFSET(From, To, type_, value_)  Description Macro to define the offset between two absolute units. Requires the value to be in the destination units e.g  BOOST_UNITS_DEFINE_CONVERSION_OFFSET(celsius_base_unit, fahrenheit_base_unit, double, 32.0);   BOOST_UNITS_DEFINE_CONVERSION_FACTOR is also necessary to specify the conversion factor. Like BOOST_UNITS_DEFINE_CONVERSION_FACTOR this macro defines both forward and reverse conversions so defining, e.g., the conversion from celsius to fahrenheit as above will also define the inverse conversion from fahrenheit to celsius.      Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_UNITS_METRIC_PREFIXhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_METRIC_PREFIX_idp349191152.html    Macro BOOST_UNITS_METRIC_PREFIX           Home Libraries People FAQ More         Macro BOOST_UNITS_METRIC_PREFIX BOOST_UNITS_METRIC_PREFIX  Synopsis // In header: &lt;boost/units/systems/si/prefixes.hpp&gt;  BOOST_UNITS_METRIC_PREFIX(exponent, name)    Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_UNITS_NO_COMPILER_CHECKhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_NO_COMPILER_CHECK.html    Macro BOOST_UNITS_NO_COMPILER_CHECK           Home Libraries People FAQ More         Macro BOOST_UNITS_NO_COMPILER_CHECK BOOST_UNITS_NO_COMPILER_CHECK  Synopsis // In header: &lt;boost/units/config.hpp&gt;  BOOST_UNITS_NO_COMPILER_CHECK  Description If defined will disable a preprocessor check that the compiler is able to handle the library.      Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITYhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY.html    Macro BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY           Home Libraries People FAQ More         Macro BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY  Synopsis // In header: &lt;boost/units/config.hpp&gt;  BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY  Description If defined will trigger a static assertion if quantity&lt;Unit, T&gt; is not layout compatible with T      Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_UNITS_STATIC_CONSTANThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_UNITS_STATIC_CONSTANT.html    Macro BOOST_UNITS_STATIC_CONSTANT           Home Libraries People FAQ More         Macro BOOST_UNITS_STATIC_CONSTANT BOOST_UNITS_STATIC_CONSTANT  Synopsis // In header: &lt;boost/units/static_constant.hpp&gt;  BOOST_UNITS_STATIC_CONSTANT(name, type)  Description A convenience macro that allows definition of static constants in headers in an ODR-safe way.      Copyright &#169; 2003-2008 Matthias Christian SchabelCopyright &#169; 2007-2010 Steven       Watanabe         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_VARAINT_MAX_MULTIVIZITOR_PARAMShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_VARAINT_MAX_MULTIVIZITOR_PARAMS.html    Macro BOOST_VARAINT_MAX_MULTIVIZITOR_PARAMS           Home Libraries People FAQ More         Macro BOOST_VARAINT_MAX_MULTIVIZITOR_PARAMS BOOST_VARAINT_MAX_MULTIVIZITOR_PARAMS &#8212; Controls maximum amount of variant           parameters for multi visistors. Not used when std::tuple is available and           BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES           is not defined.  Synopsis // In header: &lt;boost/variant/multivisitors.hpp&gt;  BOOST_VARAINT_MAX_MULTIVIZITOR_PARAMS  Description Note: Default amount is 4. Define it            to bigger value before including &lt;boost/variant/multivisitors.hpp&gt; to           increase maximum amount of variant           parameters for apply_visitor.     Copyright &#169; 2002, 2003 Eric Friedman, Itay MamanDistributed under the Boost Software License, Version 1.0.     (See accompanying file LICENSE_1_0.txt or copy at      http://www.boost.org/LICENSE_1_0.txt)              
Macro BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATEShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES.html    Macro BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES           Home Libraries People FAQ More         Macro BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES &#8212; If this macro is defined, then library won't use C++11 variadic templates.         Users may define this macro to make          BOOST_VARIANT_ENUM_PARAMS         and BOOST_VARIANT_ENUM_SHIFTED_PARAMS expand         to a comma-separated sequence instead of variadic templates. Define this macro if         your compiler has problems with compilation of variadic templates.         Synopsis // In header: &lt;boost/variant/variant_fwd.hpp&gt;  BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES    Copyright &#169; 2002, 2003 Eric Friedman, Itay MamanDistributed under the Boost Software License, Version 1.0.     (See accompanying file LICENSE_1_0.txt or copy at      http://www.boost.org/LICENSE_1_0.txt)              
Macro BOOST_VARIANT_ENUM_PARAMShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_VARIANT_ENUM_PARAMS.html    Macro BOOST_VARIANT_ENUM_PARAMS           Home Libraries People FAQ More         Macro BOOST_VARIANT_ENUM_PARAMS BOOST_VARIANT_ENUM_PARAMS &#8212; Enumerate parameters for use with         variant.  Synopsis // In header: &lt;boost/variant/variant_fwd.hpp&gt;  BOOST_VARIANT_ENUM_PARAMS(param)  Description  When variadic templates are available and         BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES         is not defined, expands to variadic template list in the following manner:                      BOOST_VARIANT_ENUM_PARAMS(T)                    =&gt; T0, TN...             BOOST_VARIANT_ENUM_PARAMS(class T)              =&gt; class T0, class... TN             BOOST_VARIANT_ENUM_PARAMS(class Something)      =&gt; class Something0, class... SomethingN             BOOST_VARIANT_ENUM_PARAMS(typename Something)   =&gt; typename Something0, typename... SomethingN             BOOST_VARIANT_ENUM_PARAMS(Something)            =&gt; Something0, SomethingN...             BOOST_VARIANT_ENUM_PARAMS(Something)            =&gt; Something0, SomethingN...                          Otherwise expands to a comma-separated sequence of length         BOOST_VARIANT_LIMIT_TYPES, where         each element in the sequence consists of the concatenation of         param with its zero-based index into the         sequence. That is,         param ## 0, param ## 1, ..., param ## BOOST_VARIANT_LIMIT_TYPES - 1. Rationale: This macro greatly         simplifies for the user the process of declaring         variant types         in function templates or explicit partial specializations of class         templates, as shown in the         tutorial.     Copyright &#169; 2002, 2003 Eric Friedman, Itay MamanDistributed under the Boost Software License, Version 1.0.     (See accompanying file LICENSE_1_0.txt or copy at      http://www.boost.org/LICENSE_1_0.txt)              
Macro BOOST_VARIANT_ENUM_SHIFTED_PARAMShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_VARIANT_ENUM_SHIFTED_PARAMS.html    Macro BOOST_VARIANT_ENUM_SHIFTED_PARAMS           Home Libraries People FAQ More         Macro BOOST_VARIANT_ENUM_SHIFTED_PARAMS BOOST_VARIANT_ENUM_SHIFTED_PARAMS &#8212; Enumerate all but the first parameter for use with         variant.  Synopsis // In header: &lt;boost/variant/variant_fwd.hpp&gt;  BOOST_VARIANT_ENUM_SHIFTED_PARAMS(param)  Description  When variadic templates are available and         BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES         is not defined, expands to variadic template list in the following manner:                      BOOST_VARIANT_ENUM_SHIFTED_PARAMS(T)                    =&gt; TN...             BOOST_VARIANT_ENUM_SHIFTED_PARAMS(class T)              =&gt; class... TN             BOOST_VARIANT_ENUM_SHIFTED_PARAMS(class Something)      =&gt; class... SomethingN             BOOST_VARIANT_ENUM_SHIFTED_PARAMS(typename Something)   =&gt; typename... SomethingN             BOOST_VARIANT_ENUM_SHIFTED_PARAMS(Something)            =&gt; SomethingN...             BOOST_VARIANT_ENUM_SHIFTED_PARAMS(Something)            =&gt; SomethingN...                          Otherwise expands to a comma-separated sequence of length         BOOST_VARIANT_LIMIT_TYPES - 1,         where each element in the sequence consists of the concatenation of         param with its one-based index into the sequence.         That is,         param ## 1, ..., param ## BOOST_VARIANT_LIMIT_TYPES - 1. Note: This macro results in the         same expansion as         BOOST_VARIANT_ENUM_PARAMS -- but         without the first term.     Copyright &#169; 2002, 2003 Eric Friedman, Itay MamanDistributed under the Boost Software License, Version 1.0.     (See accompanying file LICENSE_1_0.txt or copy at      http://www.boost.org/LICENSE_1_0.txt)              
Macro BOOST_VARIANT_LIMIT_TYPEShttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_VARIANT_LIMIT_TYPES.html    Macro BOOST_VARIANT_LIMIT_TYPES           Home Libraries People FAQ More         Macro BOOST_VARIANT_LIMIT_TYPES BOOST_VARIANT_LIMIT_TYPES &#8212; Expands to the length of the         template parameter list for         variant. Not used if         BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES         is not defined.          Synopsis // In header: &lt;boost/variant/variant_fwd.hpp&gt;  BOOST_VARIANT_LIMIT_TYPES  Description Note: Conforming         implementations of variant must allow at least ten         template arguments. That is, BOOST_VARIANT_LIMIT_TYPES must be greater         or equal to 10.     Copyright &#169; 2002, 2003 Eric Friedman, Itay MamanDistributed under the Boost Software License, Version 1.0.     (See accompanying file LICENSE_1_0.txt or copy at      http://www.boost.org/LICENSE_1_0.txt)              
Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT.html    Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT           Home Libraries People FAQ More         Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT &#8212; Indicates         make_recursive_variant operates in         an implementation-defined manner.  Synopsis // In header: &lt;boost/variant/variant_fwd.hpp&gt;  BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT  Description Defined only if         make_recursive_variant does not         operate as documented on the target compiler, but rather in an         implementation-defined manner. Implementation Note: If         BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT is         defined for the target compiler, the current implementation uses the         MPL lambda mechanism to approximate the         desired behavior. (In most cases, however, such compilers do not have         full lambda support either.)     Copyright &#169; 2002, 2003 Eric Friedman, Itay MamanDistributed under the Boost Software License, Version 1.0.     (See accompanying file LICENSE_1_0.txt or copy at      http://www.boost.org/LICENSE_1_0.txt)              
Macro BOOST_VARIANT_NO_REFERENCE_SUPPORThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_VARIANT_NO_REFERENCE_SUPPORT.html    Macro BOOST_VARIANT_NO_REFERENCE_SUPPORT           Home Libraries People FAQ More         Macro BOOST_VARIANT_NO_REFERENCE_SUPPORT BOOST_VARIANT_NO_REFERENCE_SUPPORT &#8212; Indicates variant does not         support references as bounded types.  Synopsis // In header: &lt;boost/variant/variant_fwd.hpp&gt;  BOOST_VARIANT_NO_REFERENCE_SUPPORT  Description Defined only if variant does         not support references as bounded types.     Copyright &#169; 2002, 2003 Eric Friedman, Itay MamanDistributed under the Boost Software License, Version 1.0.     (See accompanying file LICENSE_1_0.txt or copy at      http://www.boost.org/LICENSE_1_0.txt)              
Macro BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORThttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT.html    Macro BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT           Home Libraries People FAQ More         Macro BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT &#8212; Indicates absence of support for specifying the bounded types         of a variant by the elements of a         type sequence.  Synopsis // In header: &lt;boost/variant/variant_fwd.hpp&gt;  BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT  Description Defined only if         make_variant_over and         make_recursive_variant_over         are not supported for some reason on the target compiler.     Copyright &#169; 2002, 2003 Eric Friedman, Itay MamanDistributed under the Boost Software License, Version 1.0.     (See accompanying file LICENSE_1_0.txt or copy at      http://www.boost.org/LICENSE_1_0.txt)              
Macro BOOST_XPR_ENSURE_https://www.boost.org/doc/libs/1_59_0/doc/BOOST_XPR_ENSURE_.html    Macro BOOST_XPR_ENSURE_           Home Libraries People FAQ More         Macro BOOST_XPR_ENSURE_ BOOST_XPR_ENSURE_  Synopsis // In header: &lt;boost/xpressive/regex_error.hpp&gt;  BOOST_XPR_ENSURE_(pred, code, msg)    Copyright &#169; 2007 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Macro BOOST_XPRESSIVE_HAS_MS_STACK_GUARDhttps://www.boost.org/doc/libs/1_59_0/doc/BOOST_XPRESSIVE_HAS_MS_STACK_GUARD.html    Macro BOOST_XPRESSIVE_HAS_MS_STACK_GUARD           Home Libraries People FAQ More         Macro BOOST_XPRESSIVE_HAS_MS_STACK_GUARD BOOST_XPRESSIVE_HAS_MS_STACK_GUARD  Synopsis // In header: &lt;boost/xpressive/xpressive_fwd.hpp&gt;  BOOST_XPRESSIVE_HAS_MS_STACK_GUARD    Copyright &#169; 2007 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Chapter&#160;40.&#160;The BoostBook Documentation Formathttps://www.boost.org/doc/libs/1_59_0/doc/boostbook.html    Chapter&#160;40.&#160;The BoostBook Documentation Format           Home Libraries People FAQ More         Chapter&#160;40.&#160;The BoostBook Documentation Format  Douglas Gregor  Copyright &#169; 2003-2005 Douglas Gregor  Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at       http://www.boost.org/LICENSE_1_0.txt).           Table of Contents  Introduction Getting Started  Automatic setup for Unix-like systems Manual setup for all systems Running BoostBook Troubleshooting  Documenting libraries  Defining a BoostBook library From HTML to BoostBook Sectioning in BoostBook  Bringing Together a BoostBook Document Linking in BoostBook Reference      Introduction The BoostBook documentation format is an extension of DocBook, an SGML- or     XML-based format for describing documentation. BoostBook augments     DocBook with semantic markup that aids in the documentation of C++     libraries, specifically the Boost C++ libraries, by     providing the ability to express and refer to C++ constructs such     as namespaces, classes, overloaded functions, templates, and     specializations.      BoostBook offers additional features more specific to its use for     documenting the Boost C++     libraries. These features are intended to eliminate or     reduce the need for duplication of information and to aid in     documenting portions of Boost that might otherwise not be     documented. Examples of Boost-centric features include:         Testsuites:           Testsuites in Boost are created by writing an appropriate           Jamfile and including that Jamfile in           status/Jamfile. If the testsuites are           documented (as           in the MultiArray library), the documentation is           maintained separately from the testcase Jamfile, leading to           duplication of information and the possibility of having the           documentation out of sync with the Jamfile. BoostBook           contains elements that describe a testsuite for both           purposes: the BoostBook stylesheets can generate           documentation for the testcases and also generate an           appropriate Jamfile to integrate the testcases with the           regression testing system.  Example programs:           Example programs in documentation need to be duplicated in           testcases to ensure that the examples compile and execute           correctly. Keeping the two copies in sync is a tedious and           error-prone task. For instance, the following code snippet           persisted for six months:  std::cout &lt;&lt; f(5, 3) &gt;&gt; std::endl;  The BoostBook format allows testcases to be generated           by weaving together program fragments from example programs           in the documentation. This capability is integrated with           testsuite generation so that example programs are normal           tests in BoostBook.                     
Concept CallableTransformhttps://www.boost.org/doc/libs/1_59_0/doc/CallableTransform.html    Concept CallableTransform           Home Libraries People FAQ More         Concept CallableTransform CallableTransform   Description        A CallableTransform is a function type or a function       pointer type where the return type Fn is a       PolymorphicFunctionObject and the arguments are       Transforms. is_callable&lt; Fn &gt;::value       must be true. The CallableTransform, when applied,       has the effect of invoking the polymorphic function       object Fn, passing as arguments the result(s)       of applying transform(s) Tn.        Associated types  result_type boost::result_of&lt;Fn(Transform&lt;Tn, Expr, State, Data&gt;::result_type...)&gt;::type         The result of applying the CallableTransform.          Notation  Fn A type playing the role of polymorphic-function-object-type in the CallableTransform concept. Tn A type playing the role of transform-type in the CallableTransform concept. Expr A type playing the role of expression-type in the CallableTransform concept. State A type playing the role of state-type in the CallableTransform concept. Data A type playing the role of data-type in the CallableTransform concept. fn Object of type Fn expr Object of type Expr state Object of type State data Object of type Data    Valid expressions         Name Expression Type Semantics   Apply Transform when&lt; _, Fn(Tn...)&gt;()(expr, state, data) result_type Applies the transform.     Models boost::proto::_child(boost::proto::_left)     Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Chapter&#160;6.&#160;Boost.Chrono 2.0.5https://www.boost.org/doc/libs/1_59_0/doc/chrono.html    Chapter&#160;6.&#160;Boost.Chrono 2.0.5           Home Libraries People FAQ More         Chapter&#160;6.&#160;Boost.Chrono 2.0.5  Howard Hinnant   Beman Dawes   Vicente J. Botet Escriba  Copyright &#169; 2008 Howard Hinnant Copyright &#169; 2006, 2008 Beman Dawes Copyright &#169; 2009-2013 Vicente J. Botet Escriba           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Overview  Motivation Description  User's Guide  Getting Started Tutorial Examples External Resources  Reference   Header &lt;boost/chrono/include.hpp&gt; Included on the C++11 Recommendation Chrono I/O V1 Chrono I/O V2 Chrono Rounding Utilities Other Clocks  Appendices  Appendix: History Appendix: Rationale Appendix: Implementation       Notes Appendix: FAQ Appendix: Acknowledgements Appendix: Future plans         ]         ]      Overview   Motivation Description           &#8220;What is time, then? If nobody asks me, I know; if I have to explain         it to someone who has asked me, I do not know."&#8221;                 -- Augustine                 How       to Use This Documentation             This documentation makes use of the following naming and formatting conventions.                  Code is in fixed width           font and is syntax-highlighted.                     Replaceable text that you will need to supply is in italics.                     Free functions are rendered in the code font followed by (), as in free_function().                     If a name refers to a class template, it is specified like this: class_template&lt;&gt;;           that is, it is in code font and its name is followed by &lt;&gt;           to indicate that it is a class template.                     If a name refers to a function-like macro, it is specified like this:           MACRO();           that is, it is uppercase in code font and its name is followed by () to indicate that it is a function-like           macro. Object-like macros appear without the trailing ().                     Names that refer to concepts in the generic programming           sense are specified in CamelCase.              Note           In addition, notes such as this one specify non-essential information that         provides additional background or rationale.                Finally, you can mentally add the following to any code fragments in this document:      // Include all of Chrono files #include &lt;boost/chrono.hpp&gt;    Motivation            Time                 We all deal with time every day of our lives. We've intuitively known it         since birth. Thus we are all very familiar with it and believe it to be a         simple matter. The modeling of time in computer programs should be similarly         simple. The unfortunate truth is that this perceived simplicity is only skin         deep. Fortunately, we do not need a terribly complicated solution to meet         the bulk of our needs. However, overly simplistic solutions can be dangerous         and inefficient, and won't adapt as the computer industry evolves.                 Boost.Chrono implements the new time facilities         in C++11, as proposed in N2661 - A Foundation to Sleep On. That document         provides background and motivation for key design decisions and is the source         of a good deal of information in this documentation.                 In addition to the clocks provided by the standard proposal, Boost.Chrono         provides specific process and thread clocks.                  Wall         clock versus system and user time                 To make the timing facilities of Boost.Chrono more generally useful, the         library provides a number of clocks that are thin wrappers around the operating         system's process time API, thereby allowing the extraction of wall clock         time, user CPU time, and system CPU time of the process. Wall clock time         is the sum of CPU time and system CPU time. (On POSIX-like systems, this         relies on times().         On Windows, it relies on GetProcessTimes().)           Description           The Boost.Chrono library provides:                  Standard                      A means to represent time durations: managed by the generic duration class . Examples of             time durations include days, minutes, seconds and nanoseconds, which can be represented             with a fixed number of clock ticks per unit. All of these units of time             duration are united with a generic interface by the duration facility.                         A type for representing points in time: time_point. A time_point represents an epoch             plus or minus a duration. The library leaves             epochs unspecified. A time_point is associated with             a clock.                         Several clocks, some of which may not be available on a particular platform:             system_clock, steady_clock and high_resolution_clock. A clock             is a pairing of a time_point and duration, and a function which             returns a time_point representing now.                       Other         clocks                 To make the timing facilities more generally useful, Boost.Chrono         provides a number of clocks that are thin wrappers around the operating system's         time APIs, thereby allowing the extraction of wall clock time, user CPU time,         system CPU time spent by the process,                      process_real_cpu_clock, captures             wall clock CPU time spent by the current process.                         process_user_cpu_clock, captures             user-CPU time spent by the current process.                         process_system_cpu_clock, captures             system-CPU time spent by the current process.                         A tuple-like class process_cpu_clock, that captures             real, user-CPU, and system-CPU process times together.                         A thread_clock thread steady clock             giving the time spent by the current thread (when supported by a platform).                      Lastly, Boost.Chrono includes typeof         registration for duration and time_point to permit using emulated         auto with C++03 compilers.                  I/O                 It provides I/O for duration and time_point. This I/O makes use of         these types much more convenient. In following the "you only pay for         what you use" philosophy, this extra functionality is located in a header         separate from &lt;boost/chrono/chrono.hpp&gt;, namely &lt;boost/chrono/chrono_io.hpp&gt;.                 It builds on &lt;boost/ratio/ratio_io.hpp&gt;         to provide readable and flexible formatting and parsing for types in &lt;boost/chrono.hpp&gt;.         This textural representation uses SI         prefixes whenever possible. This makes it easy for boost::milliseconds to be represented by the text         "milliseconds", or a hypothetical meter class to print out "millimeter".         The duration and the time_point i/o can be customized         through the new facets: duration_units and __time_point_units.         The user can specialize these facets so that the chrono i/o could be localizable.         However Boost.Chrono doesn't provides a complete locale solution.                 system_clock::time_point I/O is proposed in terms of         UTC timepoints, strongly guided by ISO 9899:1999, Programming languages -         C, ISO 9945:2003, Information Technology - Portable Operating System Interface         (POSIX) and ISO 8601:2004, Data elements and interchange formats - Information         interchange - Representation of dates and times.                  Rounding         utilities                 A few simple rounding utility functions for working with durations.                  Caveat         Emptor                 The underlying clocks provided by operating systems are subject to many seemingly         arbitrary policies and implementation irregularities. That's a polite way         of saying they tend to be flakey, and each operating system or even each         clock has its own cruel and unusual forms of flakiness. Don't bet the farm         on their accuracy, unless you have become deeply familiar with exactly what         the specific operating system is guaranteeing, which is often very little.            Last revised: August 04, 2015 at 09:04:48 GMT         
Chapter&#160;7.&#160;Boost.Circular Bufferhttps://www.boost.org/doc/libs/1_59_0/doc/circular_buffer.html    Chapter&#160;7.&#160;Boost.Circular Buffer           Home Libraries People FAQ More         Chapter&#160;7.&#160;Boost.Circular Buffer  Jan Gaspar  Copyright &#169; 2003-2013 Jan Gaspar           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Circular_buffer example Rationale Implementation  More Examples Header Files Modelled Concepts Template Parameters Trac Tickets Release Notes Acknowledgements Documentation Version Info Boost.Circular_buffer C++ Reference  Header &lt;boost/circular_buffer.hpp&gt; Header &lt;boost/circular_buffer/base.hpp&gt; Header &lt;boost/circular_buffer/debug.hpp&gt; Header &lt;boost/circular_buffer/details.hpp&gt; Header &lt;boost/circular_buffer/space_optimized.hpp&gt;  Index      Note         A printer-friendly PDF version of this manual is also available.         Introduction         A Circular Buffer.              Description             The term circular       buffer (also called a ring or cyclic       buffer) refers to an area in memory which is used to store incoming       data. When the buffer is filled, new data is written starting at the beginning       of the buffer and overwriting the old.             boost::circular_buffer       is a STL compliant container.             It is a kind of sequence similar to std::list       or std::deque.       It supports random access iterators, constant time insert and erase operations       at the beginning or the end of the buffer and interoperability with std algorithms.             The circular_buffer is       especially designed to provide fixed capacity       storage. When its capacity is exhausted, newly inserted elements will cause       elements to be overwritten, either at the beginning or end of the buffer (depending       on what insert operation is used).             The circular_buffer only       allocates memory when created, when the capacity is adjusted explicitly, or       as necessary to accommodate resizing or assign operations.                          There is also a circular_buffer_space_optimized       version available.                          circular_buffer_space_optimized       is an adaptation of the circular_buffer       which does not allocate memory all at once when created,       instead it allocates memory as needed.             The predictive memory allocation is similar to typical std::vector       implementation. Memory is automatically freed as the size of the container       decreases.             The memory allocation process of the space-optimized circular buffer. The       min_capacity       of the capacity controller represents the minimal guaranteed amount of allocated       memory. The allocated memory will never drop under this value. The default       value of the min_capacity is       set to 0. The min_capacity       can be set using the constructor parameter ()       capacity_control  or the function set_capacity.             The space-optimized version is, of course, a little slower.         Last revised: August 04, 2015 at 09:04:50 GMT         
Chapter&#160;8.&#160;Boost.Containerhttps://www.boost.org/doc/libs/1_59_0/doc/container.html    Chapter&#160;8.&#160;Boost.Container           Home Libraries People FAQ More         Chapter&#160;8.&#160;Boost.Container  Ion Gaztanaga  Copyright &#169; 2009-2013 Ion Gaztanaga           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction  Building       Boost.Container Tested compilers  Main features  Efficient insertion Containers       of Incomplete Types SCARY iterators Other features  Boost.Container and C++ exceptions Non-standard containers  stable_vector flat_(multi)map/set       associative containers slist static_vector small_vector  Extended functionality  Default       initialization for vector-like containers Ordered       range insertion for associative containers (ordered_unique_range,       ordered_range)  Configurable       tree-based associative ordered containers Constant-time       range splice for (s)list Extended       allocators  C++11/C++14 Conformance  Move and Emplace Stateful       allocators Scoped       allocators Insertion       hints in associative containers and preserving insertion ordering for elements       with equivalent keys Initializer       lists Null Forward       Iterators forward_list&lt;T&gt; vector vs. std::vector       exception guarantees Parameter       taken by const reference that can be changed vector&lt;bool&gt; specialization Non-standard       value initialization using std::memset  Known Issues Move       emulation limitations in C++03 compilers History and reasons to use     Boost.Container  Boost.Container       history Why       Boost.Container?  Indexes  Class Index Typedef Index Function Index  Boost.Container Header Reference  Header &lt;boost/container/adaptive_pool.hpp&gt; Header &lt;boost/container/allocator.hpp&gt; Header &lt;boost/container/allocator_traits.hpp&gt; Header &lt;boost/container/container_fwd.hpp&gt; Header &lt;boost/container/deque.hpp&gt; Header &lt;boost/container/flat_map.hpp&gt; Header &lt;boost/container/flat_set.hpp&gt; Header &lt;boost/container/list.hpp&gt; Header &lt;boost/container/map.hpp&gt; Header &lt;boost/container/new_allocator.hpp&gt; Header &lt;boost/container/node_allocator.hpp&gt; Header &lt;boost/container/options.hpp&gt; Header &lt;boost/container/scoped_allocator.hpp&gt; Header &lt;boost/container/scoped_allocator_fwd.hpp&gt; Header &lt;boost/container/set.hpp&gt; Header &lt;boost/container/slist.hpp&gt; Header &lt;boost/container/small_vector.hpp&gt; Header &lt;boost/container/stable_vector.hpp&gt; Header &lt;boost/container/static_vector.hpp&gt; Header &lt;boost/container/string.hpp&gt; Header &lt;boost/container/throw_exception.hpp&gt; Header &lt;boost/container/vector.hpp&gt;  Acknowledgements, notes     and links Release Notes  Boost       1.59 Release Boost       1.58 Release Boost       1.57 Release Boost       1.56 Release Boost       1.55 Release Boost       1.54 Release Boost       1.53 Release Boost       1.52 Release Boost       1.51 Release Boost       1.50 Release Boost       1.49 Release Boost       1.48 Release      Introduction   Building       Boost.Container Tested compilers         Boost.Container library implements several       well-known containers, including STL containers. The aim of the library is       to offers advanced features not present in standard containers or to offer       the latest standard draft features for compilers that comply with C++03.             In short, what does Boost.Container offer?                  Move semantics are implemented, including move emulation for pre-C++11           compilers.                     New advanced features (e.g. placement insertion, recursive containers)           are present.                     Containers support stateful allocators and are compatible with Boost.Interprocess (they can be safely placed in           shared memory).                     The library offers new useful containers:                             flat_map,                 flat_set,                 flat_multimap                 and flat_multiset:                 drop-in replacements for standard associative containers but more                 memory friendly and with faster searches.                                 stable_vector:                 a std::list and std::vector hybrid container: vector-like random-access                 iterators and list-like iterator stability in insertions and erasures.                                 slist: the classic                 pre-standard singly linked list implementation offering constant-time                 size().                 Note that C++11 forward_list                 has no size().                             Building       Boost.Container           There is no need to compile Boost.Container         if you don't use Extended         Allocators since in that case it's a header-only library. Just include         your Boost header directory in your compiler include path.                 Extended         Allocators are implemented as a separately compiled library, so you         must install binaries in a location that can be found by your linker when         using these classes. If you followed the Boost         Getting Started instructions, that's already been done for you.           Tested compilers           Boost.Container requires a decent C++98         compatibility. Some compilers known to work are:                      Visual C++ &gt;= 7.1.                         GCC &gt;= 4.1.                         Intel C++ &gt;= 9.0                 Last revised: August 04, 2015 at 09:04:58 GMT         
Redirect to generated documentationhttps://www.boost.org/doc/libs/1_59_0/doc/CopyConstructible.html               Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at       http://www.boost.org/LICENSE_1_0.txt) -->     Redirect to generated documentation                Automatic redirection failed, please go to     http://www.boost.org/doc/libs/master/doc/html/CopyConstructible.html     
Chapter&#160;9.&#160;Boost.Date_Timehttps://www.boost.org/doc/libs/1_59_0/doc/date_time.html    Chapter&#160;9.&#160;Boost.Date_Time           Home Libraries People FAQ More         Chapter&#160;9.&#160;Boost.Date_Time  Jeff Garland  Copyright &#169; 2001-2005 CrystalClear Software, Inc  Subject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)    Table of Contents  Conceptual  Motivation Domain Concepts Design Concepts  General Usage Examples Gregorian  Date Date Duration (aka Days) Date Period Date Iterators Date Generators/Algorithms Gregorian Calendar  Posix Time  Ptime Time Duration Time Period Time Iterators  Local Time  Time Zone (abstract) Posix Time Zone Time Zone Database Custom Time Zone Local Date Time Local Time Period  Date Time Input/Output  Format Flags Date Facet Date Input Facet Time Facet Time Input Facet Date Time Formatter/Parser Objects Date Time IO Tutorial  Serialization Details  Calculations Design Goals Tradeoffs: Stability, Predictability, and Approximations Terminology References Build-Compiler Information Tests Change History Acknowledgements  Examples  Dates as Strings Days Alive Days Between New Years Last Day of the Months Localization Demonstration Date Period Calculations Print Holidays Print Month Month Adding Time Math Print Hours Local to UTC Conversion Time Periods Simple Time Zones Daylight Savings Calc Rules Flight Time Example Seconds Since Epoch  Library Reference  Date Time Reference Gregorian Reference Posix Time Reference Local Time Reference     Introduction      A set of date-time libraries based on generic programming concepts.    This documentation is also available in PDF format. It can be found at:      http://www.crystalclearsoftware.com/libraries/date_time/date_time.pdf      In addition, a full doxygen reference can be found at:      http://www.crystalclearsoftware.com/libraries/date_time/ref_guide/index.html      The most current version of the documentation can be found at:      http://www.crystalclearsoftware.com/libraries/date_time/index.html       Conceptual  Motivation Domain Concepts Design Concepts    Motivation      The motivation for this library comes from working with and helping build several date-time libraries on several projects. Date-time libraries provide fundamental infrastructure for most development projects. However, most of them have limitations in their ability to calculate, format, convert, or perform some other functionality. For example, most libraries do not correctly handle leap seconds, provide concepts such as infinity, or provide the ability to use high resolution or network time sources.  These libraries also tend to be rigid in their representation of dates and times. Thus customized policies for a project or subproject are not possible.         Programming with dates and times should be almost as simple and natural as programming with strings and integers.  Applications with lots of temporal logic can be radically simplified by having a robust set of operators and calculation capabilities. Classes should provide the ability to compare dates and times, add lengths or time durations, retrieve dates and times from  clocks, and work naturally with date and time intervals.         Another motivation for development of the library was to apply modern C++ library design techniques to the date-time domain.  Really to build a framework for the construction of building temporal types. For example, by providing iterators and traits classes to control fundamental properties of the library. To the authors knowledge this library is the only substantial attempt to apply modern C++ to a date-time library.       Domain Concepts      The date time domain is rich in terminology and problems.      The following is a brief introduction to the concepts you      will find reflected in the library.          The library supports 3 basic temporal types:        Time Point -- Specifier  	for a location in the time continuum.         Time Duration -- A  	length of time unattached to any point on the time continuum.         Time Interval -- A duration  	of time attached to a specific point in the time continuum.  	Also known as a time period.                   Each of these temporal types has a Resolution which is defined by the smallest representable duration. A Time system provides all these categories of temporal types as well as the rules for labeling and calculating with time points. Calendar Systems are simply time systems with a maximum resolution of one day. The Gregorian system is the most widely used calendar system today (the ISO system is basically a derivative of this). However, there are many other calendar systems as well. UTC (Coordinated Universal Time) is a widely used civil time system. UTC is adjusted for earth rotation at longitude 0 by the use of leap seconds (This is not predictable, only as necessary). Most local time systems are based on UTC but are also adjusted for earth rotation so that daylight hours are similar everywhere. In addition, some local times include daylight savings time (DST) adjustments to shift the daylight hours during the summer.         A Clock Device is software component (tied to some hardware) that provides the current date or time with respect to a time system. A clock can measure the current time to a known resolution which may be higher or lower than a particular time representation.          The library provides support for calculating with dates and times. However, time calculations are not quite the same as calculating with integers. If you are serious about the accuracy of your time calculations need to read about Stability, Predictability, and Approximations.            Basic Terminology Calculations Stability, Predictability, and Approximations References         Design Concepts      A large part of the genesis of this library has been the observation that few date-time libraries are built in a fashion that allows customization and extension. A typical example, the calendar logic is built directly into the date class. Or the clock retrieval functions are built directly into the time class. These design decisions usually make it impossible to extend or change the library behavior. At a more fundamental level, there are usually assumptions about the resolution of time representation or the gregorian calendar.          Often times, the result is that a project must settle for a less than complete library because of a requirement for high resolution time representation or other assumptions that do not match the implementation of the library. This is extremely unfortunate because development of a library of this sort is far from a trivial task.          While the design is far from perfect the current design is far more flexible than any date-time library the author is aware of. It is expected that the various aspects of extensibility will be better documented in future versions. Information about the design goals of the library is summarized here.                  
Concept Domainhttps://www.boost.org/doc/libs/1_59_0/doc/Domain.html    Concept Domain           Home Libraries People FAQ More         Concept Domain Domain   Description        A Domain creates an association between expressions and a so-called       generator, which is a function that maps an expression in the default       domain to an equivalent expression in this Domain. It also associates       an expression with a grammar, to which all expressions within this       Domain must conform.        Associated types   proto_grammar Domain::proto_grammar         The grammar to which every expression in this Domain         must conform.         proto_generator Domain::proto_generator                  A Unary Polymorphic Function that accepts expressions in the         default domain and emits expressions in this Domain.                proto_super_domain Domain::proto_super_domain                  The Domain that is a super-domain of this domain, if         any such domain exists. If not, it is some unspecified         type.                result_type boost::result_of&lt;Domain(Expr)&gt;::type                  The type of the result of applying         proto_generator to         the specified expression type. The result is required to         model Expr. The domain type         associated with result_type         (result_type::proto_domain)         is required to be the same type as this Domain.                as_expr_result_type Domain::as_expr&lt;Object&gt;::result_type                  The result of converting some type to a Proto expression         type in this domain. This is used, for instance, when         calculating the type of a variable to hold a Proto         expression.         as_expr_result_type         models         Expr.                as_child_result_type Domain::as_child&lt;Object&gt;::result_type                  The result of converting some type to a Proto expression         type in this domain. This is used, for instance, to         compute the type of an object suitable for storage         as a child in an expression tree.         as_child_result_type         models         Expr.                  Notation  Domain A type playing the role of domain-type in the Domain concept. Expr A type playing the role of expression-type in the Domain concept. Object A type playing the role of object-type in the Domain concept. d Object of type Domain e Object of type Expr o Object of type Object    Valid expressions         Name Expression Type Semantics    Apply Generator d(e) result_type        The result of applying proto_generator       to the specified expression.        As Expression Domain::as_expr&lt; Object &gt;()(o) as_expr_result_type        The result of converting some object to a Proto expression       in this domain. It returns a Proto expression object that       is suitable for storage in a variable. It should return a       new object, which may be a copy of the object passed in.        As Child Domain::as_child&lt; Object &gt;()(o) as_child_result_type        The result of converting some object to a Proto expression       in this domain. It returns an object suitable for storage       as a child in an expression tree, which may simply be a       reference to the object passed in.           Models boost::proto::default_domain     Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Concept Exprhttps://www.boost.org/doc/libs/1_59_0/doc/Expr.html    Concept Expr           Home Libraries People FAQ More         Concept Expr Expr   Description        An Expr represents a tagged node in an expression tree.       The children of the Expr must themselves satisfy the       Expr concept. The Expr has an arity representing the       number of children. If the number of children is zero,       the Expr also has a value. An Expr also has an associated       Domain.        Associated types   proto_tag Expr::proto_tag         The tag type of the Expr.         proto_args Expr::proto_args         A typelist representing either the types of the child nodes, or,         if the arity of the Expr is 0, of the value of the terminal.         proto_arity Expr::proto_arity                  The arity (number of child nodes) of the Expr.         proto_arity is an MPL Integral Constant.                proto_grammar Expr::proto_grammar                  A typedef for an instantiation of                    proto::basic_expr&lt;&gt;                  that is equivalent to Expr. Expression types are equivalent if they have the         same proto_tag, proto_args, and proto_arity.                proto_base_expr Expr::proto_base_expr                  A typedef for an instantiation of         proto::expr&lt;&gt; or         proto::basic_expr&lt;&gt;         that is equivalent to Expr. Expression types are equivalent if they have the         same proto_tag, proto_args, and proto_arity.                proto_derived_expr Expr::proto_derived_expr                  A typedef for Expr.                proto_domain Expr::proto_domain                  The Domain of the Expr. proto_domain         models Domain.                proto_childN Expr::proto_childN         The type of the Nth child of Expr. Requires          0 == N::value || N::value &lt; proto_arity::value           Notation  Expr A type playing the role of expession-type in the Expr concept. Tag A type playing the role of tag-type in the Expr concept. Domain A type playing the role of domain-type in the Expr concept. N A type playing the role of mpl-integral-constant-type in the Expr concept. e Object of type Expr    Valid expressions         Name Expression Type Semantics    Get N-th Child boost::proto::child&lt; N &gt;(e) proto_childN Extracts the Nth child from this Expr.       Requires N::value &lt; proto_arity::value.   Get Terminal Value boost::proto::value(e) proto_child0        Extracts the value from a terminal Expr.       Requires 0 == proto_arity::value.        Get Base e.proto_base() proto_base_expr          Returns an object of type         proto::expr&lt;&gt; or         proto::basic_expr&lt;&gt;         that is equivalent to e.           Models boost::proto::literal&lt; int &gt;     Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Chapter&#160;10.&#160;Boost.Foreachhttps://www.boost.org/doc/libs/1_59_0/doc/foreach.html    Chapter&#160;10.&#160;Boost.Foreach           Home Libraries People FAQ More         Chapter&#160;10.&#160;Boost.Foreach  Eric Niebler  Copyright &#169; 2004 Eric Niebler           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Extensibility Portability Pitfalls History and Acknowledgements     Introduction           &#8220;Make simple things easy.&#8221; --         Larry Wall                What       is BOOST_FOREACH?             In C++, writing a loop that iterates over a sequence is tedious. We can either       use iterators, which requires a considerable amount of boiler-plate, or we       can use the std::for_each()       algorithm and move our loop body into a predicate, which requires no less boiler-plate       and forces us to move our logic far from where it will be used. In contrast,       some other languages, like Perl, provide a dedicated "foreach" construct       that automates this process. BOOST_FOREACH is just such       a construct for C++. It iterates over sequences for us, freeing us from having       to deal directly with iterators or write predicates.             BOOST_FOREACH is designed for ease-of-use and efficiency.       It does no dynamic allocations, makes no virtual function calls or calls through       function pointers, and makes no calls that are not transparent to the compiler's       optimizer. This results in near-optimal code generation; the performance of       BOOST_FOREACH is usually within a few percent of the equivalent       hand-coded loop. And although BOOST_FOREACH is a macro,       it is a remarkably well-behaved one. It evaluates its arguments exactly once,       leading to no nasty surprises.              Hello,       world!             Below is a sample program that uses BOOST_FOREACH to loop       over the contents of a std::string.      #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;boost/foreach.hpp&gt;  int main() {     std::string hello( "Hello, world!" );      BOOST_FOREACH( char ch, hello )     {         std::cout &lt;&lt; ch;     }      return 0; }         This program outputs the following:      Hello, world!          Supported       Sequence Types             BOOST_FOREACH iterates over sequences. But what qualifies       as a sequence, exactly? Since BOOST_FOREACH is built on       top of Boost.Range, it automatically       supports those types which Boost.Range       recognizes as sequences. Specifically, BOOST_FOREACH works       with types that satisfy the Single       Pass Range Concept. For example, we can use BOOST_FOREACH       with:                  STL containers                     arrays                     Null-terminated strings (char           and wchar_t)                     std::pair of iterators              Note           The support for STL containers is very general; anything that looks like         an STL container counts. If it has nested iterator         and const_iterator types         and begin()         and end()         member functions, BOOST_FOREACH will automatically know         how to iterate over it. It is in this way that boost::iterator_range&lt;&gt;         and boost::sub_range&lt;&gt;         work with BOOST_FOREACH.                See the section on Extensibility       to find out how to make BOOST_FOREACH work with other types.              Examples             Below are some examples that demonstrate all the different ways we can use       BOOST_FOREACH.             Iterate over an STL container:      std::list&lt;int&gt; list_int( /*...*/ ); BOOST_FOREACH( int i, list_int ) {     // do something with i }         Iterate over an array, with covariance (i.e., the type of the iteration variable       is not exactly the same as the element type of the container):      short array_short[] = {1,2,3}; BOOST_FOREACH( int i, array_short ) {     // The short was implicitly converted to an int }         Predeclare the loop variable, and use break,       continue, and return       in the loop body:      std::deque&lt;int&gt; deque_int( /*...*/ ); int i = 0; BOOST_FOREACH( i, deque_int ) {     if( i == 0 ) return;     if( i == 1 ) continue;     if( i == 2 ) break; }         Iterate over a sequence by reference, and modify the underlying sequence:      short array_short[] = { 1, 2, 3 }; BOOST_FOREACH( short &amp; i, array_short ) {     ++i; } // array_short contains {2,3,4} here         Iterate over a vector of vectors with nested BOOST_FOREACH       loops. In this example, notice that braces around the loop body are not necessary:      std::vector&lt;std::vector&lt;int&gt; &gt; matrix_int; BOOST_FOREACH( std::vector&lt;int&gt; &amp; row, matrix_int )     BOOST_FOREACH( int &amp; i, row )         ++i;         Iterate over an expression that returns a sequence by value (i.e. an rvalue):      extern std::vector&lt;float&gt; get_vector_float(); BOOST_FOREACH( float f, get_vector_float() ) {     // Note: get_vector_float() will be called exactly once }         Iterate in reverse:      std::list&lt;int&gt; list_int( /*...*/ ); BOOST_REVERSE_FOREACH( int i, list_int ) {     // do something with i }         Iterating over rvalues doesn't work on some older compilers. Check the Portability section to see whether your       compiler supports this.              Making       BOOST_FOREACH Prettier             People have complained about the name BOOST_FOREACH. It's       too long. ALL CAPS       can get tiresome to look at. That may be true, but BOOST_FOREACH       is merely following the Boost       Naming Convention. That doesn't mean you're stuck with it, though.       If you would like to use a different identifier (foreach_,       perhaps), you can simply do:      #define foreach_         BOOST_FOREACH #define foreach_r_       BOOST_REVERSE_FOREACH         Only do this if you are sure that the identifier you choose will not cause       name conflicts in your code.         Note           Do not use #define foreach_(x,y) BOOST_FOREACH(x,y). This         can be problematic if the arguments are macros themselves. This would result         in an additional expansion of these macros. Instead, use the form shown above.                Lastly, a word of warning. Lots of folks use a foreach       macro as a short form for BOOST_FOREACH.       I discourage this. It leads to name conflicts within the BOOST_FOREACH       macro itself, where foreach       is the name of a namespace. Besides, foreach       is a common-enough identifier; even Qt       defines it as a macro. If you insist on using foreach,       you might try something like this:      #include &lt;boost/foreach.hpp&gt;  namespace boost {     // Suggested work-around for https://svn.boost.org/trac/boost/ticket/6131     namespace BOOST_FOREACH = foreach; }  #define foreach   BOOST_FOREACH         This will work around some of the problems you're likely       to encounter, but not all. Prefer using a different identifier.         Last revised: August 04, 2015 at 09:05:21 GMT         
Chapter&#160;11.&#160;Boost.Functionhttps://www.boost.org/doc/libs/1_59_0/doc/function.html    Chapter&#160;11.&#160;Boost.Function           Home Libraries People FAQ More         Chapter&#160;11.&#160;Boost.Function   Douglas Gregor  &lt;dgregor -at- cs.indiana.edu&gt;  Copyright &#169; 2001-2004 Douglas Gregor  Use, modification and distribution is subject to the Boost     Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)    Table of Contents  Introduction History &amp; Compatibility Notes Tutorial  Basic Usage Free functions Member functions References to Function Objects Comparing Boost.Function function objects  Reference  Definitions Header &lt;boost/function.hpp&gt; Header &lt;boost/function_equal.hpp&gt;  Frequently Asked Questions Miscellaneous Notes  Boost.Function vs. Function Pointers Performance Combatting virtual function "bloat" Acknowledgements  Testsuite  Acceptance tests Negative tests      Introduction The Boost.Function library contains a family of class templates that are function object wrappers. The notion is similar to a generalized callback. It shares features with function pointers in that both define a call interface (e.g., a function taking two integer arguments and returning a floating-point value) through which some implementation can be called, and the implementation that is invoked may change throughout the course of the program.  Generally, any place in which a function pointer would be used to defer a call or make a callback, Boost.Function can be used instead to allow the user greater flexibility in the implementation of the target. Targets can be any 'compatible' function object (or function pointer), meaning that the arguments to the interface designated by Boost.Function can be converted to the arguments of the target function object.             
Chapter&#160;12.&#160;Boost.Functional/Hashhttps://www.boost.org/doc/libs/1_59_0/doc/hash.html    Chapter&#160;12.&#160;Boost.Functional/Hash           Home Libraries People FAQ More         Chapter&#160;12.&#160;Boost.Functional/Hash  Daniel James  Copyright &#169; 2005-2008 Daniel       James           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Tutorial Extending boost::hash for a custom data type Combining hash values Portability Disabling The Extensions Change Log Rationale Reference   Header &lt;boost/functional/hash.hpp&gt;  Links Acknowledgements     Introduction         boost::hash is an implementation of       the hash function       object specified by the Draft       Technical Report on C++ Library Extensions (TR1). It is the default       hash function for Boost.Unordered, Boost.Intrusive's       unordered associative containers, and Boost.MultiIndex's       hash indicies and Boost.Bimap's       unordered_set_of.             As it is compliant with TR1,       it will work with:                  integers                     floats                     pointers                     strings                  It also implements the extension proposed by Peter Dimov in issue 6.18 of the       Library       Extension Technical Report Issues List (page 63), this adds support       for:                  arrays                     std::pair                     the standard containers.                     extending boost::hash for custom           types.              Note           This hash function is designed to be used in containers based on the STL         and is not suitable as a general purpose hash function. For more details         see the rationale.            Last revised: August 04, 2015 at 09:05:21 GMT         
Chapter&#160;13.&#160;Boost.Heaphttps://www.boost.org/doc/libs/1_59_0/doc/heap.html    Chapter&#160;13.&#160;Boost.Heap           Home Libraries People FAQ More         Chapter&#160;13.&#160;Boost.Heap  Tim Blechmann  Copyright &#169; 2010, 2011 Tim Blechmann           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction &amp; Motivation Concepts &amp; Interface  Basic Priority Queue Interface Priority Queue Iterators Comparing Priority Queues &amp;       Equivalence Merging Priority Queues Mutability Stability  Data Structures Data       Structure Configuration Reference  Header &lt;boost/heap/binomial_heap.hpp&gt; Header &lt;boost/heap/d_ary_heap.hpp&gt; Header &lt;boost/heap/fibonacci_heap.hpp&gt; Header &lt;boost/heap/heap_concepts.hpp&gt; Header &lt;boost/heap/heap_merge.hpp&gt; Header &lt;boost/heap/pairing_heap.hpp&gt; Header &lt;boost/heap/policies.hpp&gt; Header &lt;boost/heap/priority_queue.hpp&gt; Header &lt;boost/heap/skew_heap.hpp&gt;  Acknowledgements     Introduction &amp; Motivation         boost.heap is an implementation of priority queues. Priority       queues are queue data structures, that order their elements by a priority.       The STL provides a single template class std::priority_queue,       which only provides a limited functionality. To overcome these limitations,       boost.heap implements data       structures with more functionality and different performance characteristics.       Especially, it deals with additional aspects:                  Mutability: The priority of heap elements           can be modified.                     Iterators: Heaps provide iterators to           iterate all elements.                     Mergable: While all heaps can be merged,           some can be merged efficiently.                     Stability: Heaps can be configured to           be stable sorted.                     Comparison: Heaps can be compared for           equivalence.              Last revised: August 04, 2015 at 09:05:25 GMT         
The Boost C++ Libraries BoostBook Documentation Subsethttps://www.boost.org/doc/libs/1_59_0/doc/index.html    The Boost C++ Libraries BoostBook Documentation Subset         Home Libraries People FAQ More       The Boost C++ Libraries BoostBook Documentation Subset    Table of Contents  What's Included in This Document I. The Boost C++ Libraries (BoostBook Subset)  1. Boost.Accumulators 2. Boost.Align 3. Boost.Any 4. Boost.Array 5. Boost.Atomic 6. Boost.Chrono 2.0.5 7. Boost.Circular Buffer 8. Boost.Container 9. Boost.Date_Time 10. Boost.Foreach 11. Boost.Function 12. Boost.Functional/Hash 13. Boost.Heap 14. Boost.Interprocess 15. Boost.Intrusive 16. Boost.Lambda 17. Boost.Lexical_Cast 1.0 18. Boost.Lockfree 19. Boost.Move 20. Boost.MPI 21. Boost.Program_options 22. Boost.PropertyTree 23. Boost.Proto 24. Boost.Random 25. Boost.Ratio 2.1.0 26. Boost.Signals 27. Boost.Signals2 28. Boost.StaticAssert 29. Boost String Algorithms Library 30. Thread 4.5.0 31. Boost.TR1 32. Boost.Tribool 33. Boost.TypeErasure 34. Boost.TypeIndex 4.0 35. Boost.Typeof 36. Boost.Units 1.1.0 37. Boost.Unordered 38. Boost.Variant 39. Boost.Xpressive  II. Boost Tools  40. The BoostBook Documentation Format 41. Quickbook 1.6 42. Boost.Jam : 3.1.19 43. Boost.Build User Manual             
Chapter&#160;14.&#160;Boost.Interprocesshttps://www.boost.org/doc/libs/1_59_0/doc/interprocess.html    Chapter&#160;14.&#160;Boost.Interprocess           Home Libraries People FAQ More         Chapter&#160;14.&#160;Boost.Interprocess  Ion Gaztanaga  Copyright &#169; 2005-2015 Ion Gaztanaga           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction  Building       Boost.Interprocess Tested compilers  Quick Guide for the Impatient  Using shared       memory as a pool of unnamed memory blocks Creating       named shared memory objects Using an offset       smart pointer for shared memory Creating       vectors in shared memory Creating       maps in shared memory  Some basic explanations  Processes       And Threads Sharing       information between processes Persistence       Of Interprocess Mechanisms Names Of       Interprocess Mechanisms Constructors,       destructors and lifetime of Interprocess named resources Permissions  Sharing memory     between processes  Shared       memory Memory       Mapped Files More       About Mapped Regions Limitations       When Constructing Objects In Mapped Regions  Mapping Address Independent Pointer:     offset_ptr Synchronization     mechanisms  Synchronization       mechanisms overview Mutexes Conditions Semaphores Sharable       and Upgradable Mutexes Lock       Transfers Through Move Semantics File       Locks Message       Queue  Managed Memory Segments  Making       Interprocess Data Communication Easy Managed       Shared Memory Managed       Mapped File Managed       Memory Segment Features Managed       Memory Segment Advanced Features Managed       Heap Memory And Managed External Buffer  Allocators, containers     and memory allocation algorithms  Introduction       to Interprocess allocators Segregated       storage node allocators Adaptive       pool node allocators Interprocess       and containers in managed memory segments Boost       containers compatible with Boost.Interprocess  Memory allocation algorithms  simple_seq_fit:       A simple shared memory management algorithm rbtree_best_fit:       Best-fit logarithmic-time complexity allocation  Direct iostream formatting: vectorstream     and bufferstream  Formatting directly       in your character vector: vectorstream Formatting directly       in your character buffer: bufferstream  Ownership smart pointers  Intrusive       pointer Scoped       pointer Shared       pointer and weak pointer Unique       pointer  Architecture and internals  Basic guidelines From       the memory algorithm to the managed segment Allocators       and containers Performance of       Boost.Interprocess  Customizing Boost.Interprocess  Writing       a new shared memory allocation algorithm Building       custom STL compatible allocators for Boost.Interprocess Building       custom indexes  Acknowledgements,     notes and links  Notes       for Windows users Notes       for Linux users Thanks       to... Release       Notes Books       and interesting links Future       improvements...  Indexes and Reference  Indexes Boost.Interprocess Header Reference      Introduction   Building       Boost.Interprocess Tested compilers         Boost.Interprocess simplifies the use of common       interprocess communication and synchronization mechanisms and offers a wide       range of them:                  Shared memory.                     Memory-mapped files.                     Semaphores, mutexes, condition variables and upgradable mutex types to           place them in shared memory and memory mapped files.                     Named versions of those synchronization objects, similar to UNIX/Windows           sem_open/CreateSemaphore API.                     File locking.                     Relative pointers.                     Message queues.                  Boost.Interprocess also offers higher-level       interprocess mechanisms to allocate dynamically portions of a shared memory       or a memory mapped file (in general, to allocate portions of a fixed size memory       segment). Using these mechanisms, Boost.Interprocess       offers useful tools to construct C++ objects, including STL-like containers,       in shared memory and memory mapped files:                  Dynamic creation of anonymous and named objects in a shared memory or memory           mapped file.                     STL-like containers compatible with shared memory/memory-mapped files.                     STL-like allocators ready for shared memory/memory-mapped files implementing           several memory allocation patterns (like pooling).             Building       Boost.Interprocess           There is no need to compile Boost.Interprocess,         since it's a header only library. Just include your Boost header directory         in your compiler include path.                 Boost.Interprocess depends on Boost.DateTime, which needs separate compilation.         However, the subset used by Boost.Interprocess         does not need any separate compilation so the user can define BOOST_DATE_TIME_NO_LIB to avoid Boost from         trying to automatically link the Boost.DateTime.                 In POSIX systems, Boost.Interprocess uses         pthread system calls to implement classes like mutexes, condition variables,         etc... In some operating systems, these POSIX calls are implemented in separate         libraries that are not automatically linked by the compiler. For example,         in some Linux systems POSIX pthread functions are implemented in librt.a library, so you might need to add that         library when linking an executable or shared library that uses Boost.Interprocess. If you obtain linking errors related         to those pthread functions, please revise your system's documentation to         know which library implements them.           Tested compilers           Boost.Interprocess has been tested in the         following compilers/platforms:                      Visual &gt;= 7.1                         GCC &gt;= 4.1                         Intel 11                 Last revised: August 04, 2015 at 09:05:29 GMT         
Chapter&#160;15.&#160;Boost.Intrusivehttps://www.boost.org/doc/libs/1_59_0/doc/intrusive.html    Chapter&#160;15.&#160;Boost.Intrusive           Home Libraries People FAQ More         Chapter&#160;15.&#160;Boost.Intrusive  Olaf Krzikalla   Ion Gaztanaga  Copyright &#169; 2005 Olaf Krzikalla Copyright &#169; 2006-2015 Ion Gaztanaga           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction  Presenting       Boost.Intrusive Building       Boost.Intrusive  Intrusive and non-intrusive     containers  Differences       between intrusive and non-intrusive containers Properties       of Boost.Intrusive containers  How to use Boost.Intrusive  Using base hooks Using member hooks Using both hooks Object lifetime  When to use? Concept summary Presenting Boost.Intrusive     containers Safe hooks  Features of the safe mode Configuring safe-mode       assertions  Auto-unlink hooks  What's       an auto-unlink hook? Auto-unlink       hook example Auto-unlink       hooks and containers with constant-time size()  Intrusive singly linked list: slist  slist hooks slist container Example  Intrusive doubly linked list: list  list hooks list container Example  Intrusive associative containers:     set, multiset, rbtree  set, multiset       and rbtree hooks set,       multiset and rbtree containers Example  Semi-Intrusive     unordered associative containers: unordered_set, unordered_multiset  unordered_set       and unordered_multiset performance notes unordered_set       and unordered_multiset hooks unordered_set       and unordered_multiset containers Example Custom       bucket traits  Map and multimap-like interface     for associative containers Intrusive avl tree based associative     containers: avl_set, avl_multiset and avltree  avl_set,       avl_multiset and avltree hooks avl_set,       avl_multiset and avltree containers Example  Intrusive splay tree based     associative containers: splay_set, splay_multiset and , splay_tree  Advantages       and disadvantages of splay tree based containers splay_set,       splay_multiset and splaytree containers Example  Intrusive scapegoat tree based     associative containers: sg_set, sg_multiset and sgtree  sg_set,       sg_multiset and sgtree containers Example  Intrusive treap based associative     containers: treap_set, treap_multiset and treap  treap_set,       treap_multiset and treap containers Exception       safety of treap-based intrusive containers Example  Binary search tree hooks: bs_set_base_hook     and bs_set_member_hook Advanced lookup     and insertion functions for associative containers  Advanced       lookups Advanced       insertions Positional       insertions  Erasing and disposing     values from Boost.Intrusive containers Cloning Boost.Intrusive containers Using function hooks Recursive Boost.Intrusive containers Using smart pointers with     Boost.Intrusive containers Requirements       for smart pointers compatible with Boost.Intrusive Obtaining iterators     from values Any Hooks: A single hook for any Intrusive     container Concepts explained Node algorithms with custom     NodeTraits  Intrusive       singly linked list algorithms Intrusive       doubly linked list algorithms Intrusive       red-black tree algorithms Intrusive       splay tree algorithms Intrusive       avl tree algorithms Intrusive       treap algorithms  Containers with custom ValueTraits  ValueTraits       interface Custom ValueTraits       example Reusing       node algorithms for different values Simplifying       value traits definition Stateful       value traits  Thread safety guarantees Scary Iterators Stability and insertion     with hint in ordered associative containers with equivalent keys Obtaining     the same types and reducing symbol length Design Notes  Boost.Intrusive       in performance sensitive environments Boost.Intrusive       in space constrained environments Boost.Intrusive       as a basic building block Extending       Boost.Intrusive  Performance  Back       insertion and destruction Reversing Sorting Write       access Conclusions  Release Notes  Boost       1.59 Release Boost       1.58 Release Boost       1.57 Release Boost       1.56 Release Boost       1.55 Release Boost       1.54 Release Boost       1.53 Release Boost       1.51 Release Boost       1.49 Release Boost       1.48 Release Boost       1.46 Release Boost       1.45 Release Boost       1.40 Release Boost       1.39 Release Boost       1.38 Release Boost       1.37 Release Boost       1.36 Release  Tested compilers References Acknowledgements Indexes Reference  Header &lt;boost/intrusive/any_hook.hpp&gt; Header &lt;boost/intrusive/avl_set.hpp&gt; Header &lt;boost/intrusive/avl_set_hook.hpp&gt; Header &lt;boost/intrusive/avltree.hpp&gt; Header &lt;boost/intrusive/avltree_algorithms.hpp&gt; Header &lt;boost/intrusive/bs_set.hpp&gt; Header &lt;boost/intrusive/bs_set_hook.hpp&gt; Header &lt;boost/intrusive/bstree.hpp&gt; Header &lt;boost/intrusive/bstree_algorithms.hpp&gt; Header &lt;boost/intrusive/circular_list_algorithms.hpp&gt; Header &lt;boost/intrusive/circular_slist_algorithms.hpp&gt; Header &lt;boost/intrusive/derivation_value_traits.hpp&gt; Header &lt;boost/intrusive/hashtable.hpp&gt; Header &lt;boost/intrusive/intrusive_fwd.hpp&gt; Header &lt;boost/intrusive/linear_slist_algorithms.hpp&gt; Header &lt;boost/intrusive/link_mode.hpp&gt; Header &lt;boost/intrusive/list.hpp&gt; Header &lt;boost/intrusive/list_hook.hpp&gt; Header &lt;boost/intrusive/member_value_traits.hpp&gt; Header &lt;boost/intrusive/options.hpp&gt; Header &lt;boost/intrusive/pack_options.hpp&gt; Header &lt;boost/intrusive/parent_from_member.hpp&gt; Header &lt;boost/intrusive/pointer_plus_bits.hpp&gt; Header &lt;boost/intrusive/pointer_rebind.hpp&gt; Header &lt;boost/intrusive/pointer_traits.hpp&gt; Header &lt;boost/intrusive/priority_compare.hpp&gt; Header &lt;boost/intrusive/rbtree.hpp&gt; Header &lt;boost/intrusive/rbtree_algorithms.hpp&gt; Header &lt;boost/intrusive/set.hpp&gt; Header &lt;boost/intrusive/set_hook.hpp&gt; Header &lt;boost/intrusive/sg_set.hpp&gt; Header &lt;boost/intrusive/sgtree.hpp&gt; Header &lt;boost/intrusive/sgtree_algorithms.hpp&gt; Header &lt;boost/intrusive/slist.hpp&gt; Header &lt;boost/intrusive/slist_hook.hpp&gt; Header &lt;boost/intrusive/splay_set.hpp&gt; Header &lt;boost/intrusive/splaytree.hpp&gt; Header &lt;boost/intrusive/splaytree_algorithms.hpp&gt; Header &lt;boost/intrusive/treap.hpp&gt; Header &lt;boost/intrusive/treap_algorithms.hpp&gt; Header &lt;boost/intrusive/treap_set.hpp&gt; Header &lt;boost/intrusive/trivial_value_traits.hpp&gt; Header &lt;boost/intrusive/unordered_set.hpp&gt; Header &lt;boost/intrusive/unordered_set_hook.hpp&gt;      Introduction   Presenting       Boost.Intrusive Building       Boost.Intrusive    Presenting       Boost.Intrusive           Boost.Intrusive is a library presenting         some intrusive containers to the world of C++. Intrusive containers are special         containers that offer better performance         and exception safety guarantees than non-intrusive containers (like STL containers).                 The performance benefits of intrusive containers makes them ideal as a building         block to efficiently construct complex containers like multi-index containers         or to design high performance code like memory allocation algorithms.                 While intrusive containers were and are widely used in C, they became more         and more forgotten in C++ due to the presence of the standard containers         which don't support intrusive techniques.Boost.Intrusive         wants to push intrusive containers usage encapsulating the implementation         in STL-like interfaces. Hence anyone familiar with standard containers can         easily use Boost.Intrusive.           Building       Boost.Intrusive           There is no need to compile anything to use Boost.Intrusive,         since it's a header only library. Just include your Boost header directory         in your compiler include path.            Last revised: August 04, 2015 at 09:05:59 GMT         
Chapter&#160;42.&#160;Boost.Jam : 3.1.19https://www.boost.org/doc/libs/1_59_0/doc/jam.html    Chapter&#160;42.&#160;Boost.Jam : 3.1.19           Home Libraries People FAQ More         Chapter&#160;42.&#160;Boost.Jam : 3.1.19   Rene Rivera   David Abrahams   Vladimir Prus   Copyright &#169; 2003-2007 Rene Rivera, David Abrahams, Vladimir Prus           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Building B2 Language  Lexical Features Targets Rules Flow-of-Control Variables Modules  Miscellaneous  Diagnostics Bugs, Limitations Fundamentals  History     Building B2         Installing B2 after building it is simply a matter of copying       the generated executables someplace in your PATH. For building       the executables there are a set of build bootstrap scripts       to accomodate particular environments. The scripts take one optional argument,       the name of the toolset to build with. When the toolset is not given an attempt       is made to detect an available toolset and use that. The build scripts accept       these arguments:      build [toolset]         Running the scripts without arguments will give you the best chance of success.       On Windows platforms from a command console do:      cd jam source location .\build.bat         On Unix type platforms do:      cd jam source location sh ./build.sh         For the Boost.Jam source included with the Boost distribution the jam       source location is BOOST_ROOT/tools/build/v2/engine.             If the scripts fail to detect an appropriate toolset to build with your particular       toolset may not be auto-detectable. In that case, you can specify the toolset       as the first argument, this assumes that the toolset is readily available in       the PATH.         Note           The toolset used to build Boost.Jam is independent of the toolsets used for         Boost.Build. Only one version of Boost.Jam is needed to use Boost.Build.                The supported toolsets, and whether they are auto-detected, are:       Table&#160;42.1.&#160;Supported Toolsets                                         Script                                                             Platform                                                             Toolset                                                             Detection and Notes                                                                build.bat                                                             Windows NT, 2000, and XP                                                               borland  Borland C++Builder (BCC 5.5)                                                                 Common install location: "C:\Borland\BCC55"  BCC32.EXE                 in PATH                                                                                                como Comeau                 Computing C/C++                                                                                                             gcc GNU                 GCC                                                                                                             gcc-nocygwin GNU                 GCC                                                                                                             intel-win32 Intel                 C++ Compiler for Windows                                                                 ICL.EXE in PATH                                                                                               metrowerks MetroWerks                 CodeWarrior C/C++ 7.x, 8.x, 9.x                                                                  CWFolder variable configured  MWCC.EXE                 in PATH                                                                                                mingw GNU                 GCC as the MinGW                 configuration                                                                Common install location: "C:\MinGW"                                                                                              msvc Microsoft                 Visual C++ 6.x                                                                  VCVARS32.BAT already configured  %MSVCDir%                 is present in environment Common install locations: "%ProgramFiles%\Microsoft                 Visual Studio", "%ProgramFiles%\Microsoft                 Visual C++"  CL.EXE in PATH                                                                                                vc7 Microsoft                 Visual C++ 7.x                                                                  VCVARS32.BAT or VSVARS32.BAT                 already configured  %VS71COMNTOOLS% is present in                 environment  %VCINSTALLDIR% is present in environment Common                 install locations: "%ProgramFiles%\Microsoft Visual                 Studio .NET", "%ProgramFiles%\Microsoft                 Visual Studio .NET 2003"  CL.EXE                 in PATH                                                                                                vc8                 and vc9 Microsoft Visual C++ 8.x and 9.x                                                               Detection:    VCVARSALL.BAT already configured  %VS90COMNTOOLS%                 is present in environment Common install location: "%ProgramFiles%\Microsoft                 Visual Studio 9"  %VS80COMNTOOLS%                 is present in environment Common install location: "%ProgramFiles%\Microsoft                 Visual Studio 8"  CL.EXE in PATH                                                  Notes:  If VCVARSALL.BAT is called to set up the                 toolset, it is passed all the extra arguments, see below for what                 those arguments are. This can be used to build, for example, a Win64                 specific version of b2. Consult the VisualStudio                 documentation for what the possible argument values to the VCVARSALL.BAT                 are.                                                    build.sh                                                             Unix, Linux, Cygwin, etc.                                                               acc HP-UX                 aCC                                                                  aCC in PATH   uname                 is "HP-UX"                                                                                               como Comeau                 Computing C/C++                                                                como in PATH                                                                                               gcc GNU                 GCC                                                                gcc in PATH                                                                                               intel-linux Intel                 C++ for Linux                                                                  icc in PATH  Common install locations:                 "/opt/intel/cc/9.0", "/opt/intel_cc_80",                 "/opt/intel/compiler70", "/opt/intel/compiler60",                 "/opt/intel/compiler50"                                                                                               kcc Intel KAI C++                                                                 KCC in PATH                                                                                               kylix  Borland C++Builder                                                                bc++ in PATH                                                                                              mipspro SGI                 MIPSpro C                                                                 uname is "IRIX" or                 "IRIX64"                                                                                              sunpro Sun Workshop 6 C++                                                                Standard install location: "/opt/SUNWspro"                                                                                              qcc QNX Neutrino                                                                 uname is "QNX" and                 qcc in PATH                                                                                               true64cxx Compaq                 C++ Compiler for True64 UNIX                                                                 uname is "OSF1"                                                                                              vacpp IBM                 VisualAge C++                                                                 xlc in PATH                                                                               MacOS X                                                               darwin Apple                 MacOS X GCC                                                                 uname is "Darwin"                                                                              Windows NT, 2000, and XP                                                               mingw GNU                 GCC as the MinGW                 configuration with the MSYS shell                                                                Common install location: "/mingw"                                         The built executables are placed in a subdirectory specific to your platform.       For example, in Linux running on an Intel x86 compatible chip, the executables       are placed in: "bin.linuxx86". The =b2[.exe]=       executable can be used to invoke Boost.Build.             The build scripts support additional invocation arguments for use by developers       of Boost.Jam and for additional setup of the toolset. The extra arguments come       after the toolset:                  Arguments not in the form of an option, before option arguments, are used           for extra setup to toolset configuration scripts.                     Arguments of the form "--option", which are           passed to the build.jam build script.                     Arguments not in the form of an option, after the options, which are targets           for the build.jam script.           build [toolset] [setup*] [--option+ target*]         The arguments immediately after the toolset are passed directly to the setup       script of the toolset, if available and if it needs to be invoked. This allows       one to configure the toolset ass needed to do non-default builds of b2.       For example to build a Win64 version with vc8. See the toolset       descriptiona above for when particular toolsets support this.             The arguments starting with the "--option" forms       are passed to the build.jam script and are used to further       customize what gets built. Options and targets supported by the build.jam       script:         ---              Empty option when one wants to only specify a target.            --release              The default, builds the optimized executable.            --debug              Builds debugging versions of the executable. When built they are placed             in their own directory "bin./platform/.debug".            --grammar              Normally the Jam language grammar parsing files are not regenerated.             This forces building of the grammar, although it may not force the regeneration             of the grammar parser. If the parser is out of date it will be regenerated             and subsequently built.            --with-python=path              Enables Python integration, given a path to the Python libraries.            --gc              Enables use of the Boehm Garbage Collector. The build will look for the             Boehm-GC source in a "boehm_gc" subdirectory from the b2             sources.            --duma              Enables use of the DUMA (Detect Uintended Memory Access) debugging memory             allocator. The build expects to find the DUMA source files in a "duma"             subdirectory from the b2 sources.            --toolset-root=path              Indicates where the toolset used to build is located. This option is             passed in by the bootstrap (build.bat or build.sh)             script.            --show-locate-target              For information, prints out where it will put the built executable.            --noassert              Disable debug assertions, even if building the debug version of the executable.            dist              Generate packages (compressed archives) as appropriate for distribution             in the platform, if possible.            clean              Remove all the built executables and objects.                          
Chapter&#160;16.&#160;Boost.Lambdahttps://www.boost.org/doc/libs/1_59_0/doc/lambda.html    Chapter&#160;16.&#160;Boost.Lambda           Home Libraries People FAQ More         Chapter&#160;16.&#160;Boost.Lambda   Jaakko J&#228;rvi  &lt;jarvi at cs tamu edu&gt;  Copyright &#169; 1999-2004 Jaakko J&#228;rvi, Gary Powell  Use, modification and distribution is subject to the Boost     Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)    Table of Contents  In a nutshell Getting Started  Installing the library Conventions used in this document  Introduction  Motivation Introduction to lambda expressions  Using the library  Introductory Examples Parameter and return types of lambda functors About actual arguments to lambda functors Storing bound arguments in lambda functions  Lambda expressions in details  Placeholders Operator expressions Bind expressions Overriding the deduced return type Delaying constants and variables Lambda expressions for control structures Exceptions Construction and destruction Special lambda expressions Casts, sizeof and typeid Nesting STL algorithm invocations  Extending return type deduction system Practical considerations  Performance About compiling Portability  Relation to other Boost libraries  Boost Function Boost Bind  Contributors Rationale for some of the design decisions  Lambda functor arity  Bibliography     In a nutshell         The Boost Lambda Library (BLL in the sequel) is a C++ template       library, which implements a form of lambda abstractions for C++. The term originates from functional programming and lambda calculus, where a lambda abstraction defines an unnamed function.       The primary motivation for the BLL is to provide flexible and       convenient means to define unnamed function objects for STL algorithms. In explaining what the library is about, a line of code says more than a thousand words; the       following line outputs the elements of some STL container       a separated by spaces:         for_each(a.begin(), a.end(), std::cout &lt;&lt; _1 &lt;&lt; ' ');         The expression std::cout &lt;&lt; _1 &lt;&lt; ' ' defines a unary function object.        The variable _1 is the parameter of this function, a placeholder for the actual argument.        Within each iteration of for_each, the function is       called with an element of a as the actual argument.       This actual argument is substituted for the placeholder, and the &#8220;body&#8221; of the function is evaluated.      The essence of BLL is letting you define small unnamed function objects, such as the one above, directly on the call site of an STL algorithm.         Bibliography  [STL94] A. A. Stepanov and M. Lee. The Standard Template Library. Hewlett-Packard Laboratories. 1994.  www.hpl.hp.com/techreports .    [SGI02] The SGI Standard Template Library. 2002. www.sgi.com/tech/stl/.    [C++98] International Standard, Programming Languages &#8211; C++. ISO/IEC:14882. 1998.    [J&#228;r99]  Jaakko J&#228;rvi.  C++ Function Object Binders Made Easy.  . Lecture Notes in Computer Science. 1977. Springer. 2000.    [J&#228;r00] Jaakko J&#228;rvi. Gary Powell. The Lambda Library : Lambda Abstraction in C++. Turku Centre for Computer Science. Technical Report . 378. 2000. www.tucs.fi/publications.    [J&#228;r01] Jaakko J&#228;rvi. Gary Powell. The Lambda Library : Lambda Abstraction in C++. Second  Workshop on C++ Template Programming. Tampa Bay, OOPSLA'01. . 2001. www.oonumerics.org/tmpw01/.    [J&#228;r03]   Jaakko J&#228;rvi.   Gary Powell.   Andrew Lumsdaine.  The Lambda Library : unnamed functions in C++.   . Software - Practice and Expreience. 33:259-291. 2003.    [tuple] The Boost Tuple Library. www.boost.org/libs/tuple/doc/tuple_users_guide.html . 2002.    [type_traits] The Boost type_traits. www.boost.org/libs/type_traits/ . 2002.    [ref] Boost ref. www.boost.org/libs/bind/ref.html . 2002.    [bind] Boost Bind Library. www.boost.org/libs/bind/bind.html . 2002.    [function] Boost Function Library. www.boost.org/libs/function/ . 2002.    [fc++] The FC++ library: Functional Programming in C++. Yannis Smaragdakis. Brian McNamara. www.cc.gatech.edu/~yannis/fc++/ . 2002.               
Part&#160;I.&#160;The Boost C++ Libraries (BoostBook Subset)https://www.boost.org/doc/libs/1_59_0/doc/libraries.html    Part&#160;I.&#160;The Boost C++ Libraries (BoostBook Subset)           Home Libraries People FAQ More        Part&#160;I.&#160;The Boost C++ Libraries (BoostBook Subset)  Table of Contents  1. Boost.Accumulators  Preface User's Guide Acknowledgements Reference  2. Boost.Align  Introduction Rationale Tutorial Examples Reference Vocabulary Compatibility Acknowledgments History  3. Boost.Any  Introduction Examples Reference Acknowledgements  4. Boost.Array  Introduction Reference Design Rationale For more information... Acknowledgements  5. Boost.Atomic  Introduction Thread coordination using Boost.Atomic Programming interfaces Usage examples Limitations Porting  6. Boost.Chrono 2.0.5  Overview User's Guide Reference  Appendices  7. Boost.Circular Buffer  Introduction Circular_buffer example Rationale Implementation  More Examples Header Files Modelled Concepts Template Parameters Trac Tickets Release Notes Acknowledgements Documentation Version Info Boost.Circular_buffer C++ Reference Index  8. Boost.Container  Introduction Main features Boost.Container and C++ exceptions Non-standard containers Extended functionality C++11/C++14 Conformance Known Issues History and reasons to use     Boost.Container Indexes Boost.Container Header Reference Acknowledgements, notes     and links Release Notes  9. Boost.Date_Time  Conceptual General Usage Examples Gregorian Posix Time Local Time Date Time Input/Output Serialization Details Examples Library Reference  10. Boost.Foreach  Introduction Extensibility Portability Pitfalls History and Acknowledgements  11. Boost.Function  Introduction History &amp; Compatibility Notes Tutorial Reference Frequently Asked Questions Miscellaneous Notes Testsuite  12. Boost.Functional/Hash  Introduction Tutorial Extending boost::hash for a custom data type Combining hash values Portability Disabling The Extensions Change Log Rationale Reference Links Acknowledgements  13. Boost.Heap  Introduction &amp; Motivation Concepts &amp; Interface Data Structures Reference Acknowledgements  14. Boost.Interprocess  Introduction Quick Guide for the Impatient Some basic explanations Sharing memory     between processes Mapping Address Independent Pointer:     offset_ptr Synchronization     mechanisms Managed Memory Segments Allocators, containers     and memory allocation algorithms Memory allocation algorithms Direct iostream formatting: vectorstream     and bufferstream Ownership smart pointers Architecture and internals Customizing Boost.Interprocess Acknowledgements,     notes and links Indexes and Reference  15. Boost.Intrusive  Introduction Intrusive and non-intrusive     containers How to use Boost.Intrusive When to use? Concept summary Presenting Boost.Intrusive     containers Safe hooks Auto-unlink hooks Intrusive singly linked list: slist Intrusive doubly linked list: list Intrusive associative containers:     set, multiset, rbtree Semi-Intrusive     unordered associative containers: unordered_set, unordered_multiset Map and multimap-like interface     for associative containers Intrusive avl tree based associative     containers: avl_set, avl_multiset and avltree Intrusive splay tree based     associative containers: splay_set, splay_multiset and , splay_tree Intrusive scapegoat tree based     associative containers: sg_set, sg_multiset and sgtree Intrusive treap based associative     containers: treap_set, treap_multiset and treap Binary search tree hooks: bs_set_base_hook     and bs_set_member_hook Advanced lookup     and insertion functions for associative containers Erasing and disposing     values from Boost.Intrusive containers Cloning Boost.Intrusive containers Using function hooks Recursive Boost.Intrusive containers Using smart pointers with     Boost.Intrusive containers Obtaining iterators     from values Any Hooks: A single hook for any Intrusive     container Concepts explained Node algorithms with custom     NodeTraits Containers with custom ValueTraits Thread safety guarantees Scary Iterators Stability and insertion     with hint in ordered associative containers with equivalent keys Obtaining     the same types and reducing symbol length Design Notes Performance Release Notes Tested compilers References Acknowledgements Indexes Reference  16. Boost.Lambda  In a nutshell Getting Started Introduction Using the library Lambda expressions in details Extending return type deduction system Practical considerations Relation to other Boost libraries Contributors Rationale for some of the design decisions Bibliography  17. Boost.Lexical_Cast 1.0  Motivation Examples Synopsis Frequently     Asked Questions Changes Performance  18. Boost.Lockfree  Introduction &amp;     Motivation Examples Rationale Reference Appendices  19. Boost.Move  What is Boost.Move? Introduction Implementing copyable     and movable classes Composition or inheritance Movable but Non-Copyable Types Containers and move semantics Constructor Forwarding Implicit Move when returning a local     object Move iterators Move inserters Move algorithms Emulation limitations How the library works Thanks and credits Release Notes Reference  20. Boost.MPI  Introduction Getting started Tutorial Reference Python Bindings  21. Boost.Program_options  Introduction Tutorial Library Overview How To Design Discussion Acknowledgements Reference  22. Boost.PropertyTree  What is Property Tree? Five Minute Tutorial Property Tree as a Container Property Tree Synopsis How to Populate a Property Tree How to Access Data in a Property     Tree Appendices Reference  23. Boost.Proto  Preface Users' Guide Reference Appendices  24. Boost.Random  Introduction Tutorial Reference Performance History and     Acknowledgements  25. Boost.Ratio 2.1.0  Overview User's Guide Reference  Appendices  26. Boost.Signals  Introduction Tutorial Reference Frequently Asked Questions Design Overview Design Rationale Testsuite  27. Boost.Signals2  Introduction Tutorial Example programs Reference Thread-Safety Frequently Asked Questions Design Rationale Signals2 API Changes Testsuite  28. Boost.StaticAssert  Overview and Tutorial How it works Test Programs  29. Boost String Algorithms Library  Introduction Release Notes Usage Quick Reference Design Topics Concepts Reference Rationale Environment Credits  30. Thread 4.5.0  Overview Using and building the library History Future Thread Management Scoped Threads Synchronization Thread Local Storage Synchronized Data Structures Parallel - Fork-Join -- EXPERIMENTAL Time Requirements Emulations Acknowledgments Conformance and Extension  31. Boost.TR1  Introduction Usage Configuration TR1 By Subject TR1 By Header Implementation Testing  32. Boost.Tribool  Introduction Tutorial Reference Testsuite  33. Boost.TypeErasure  Introduction How to read this documentation Basic Usage Composing Concepts Functions with Multiple Arguments Concepts in Depth Using Any Examples Concept Definitions Predefined Concepts Reference Rationale Future Work Acknowledgements Related Work  34. Boost.TypeIndex 4.0  Motivation Getting started Configuring and building the library How it works Examples Boost.TypeIndex Header Reference Making a custom     type_index Space and Performance Code bloat RTTI emulation     limitations Mixing     sources with RTTI on and RTTI off Acknowledgements  35. Boost.Typeof  Motivation Tutorial Reference Other considerations and tips Contributed By: Acknowledgements  36. Boost.Units 1.1.0  Introduction Quick Start Dimensional Analysis Units Quantities Examples Utilities Reference Installation FAQ Acknowledgements Help Wanted Version Info Release Notes TODO  37. Boost.Unordered  Introduction The Data Structure Equality Predicates and Hash Functions Comparison with Associative Containers C++11 Compliance Implementation Rationale Change Log Reference Bibliography  38. Boost.Variant  Introduction Tutorial Reference Design Overview Miscellaneous Notes References  39. Boost.Xpressive  Preface User's Guide Reference Acknowledgments Appendices               
Function template loadhttps://www.boost.org/doc/libs/1_59_0/doc/load_idp103069760.html    Function template load           Home Libraries People FAQ More         Function template load load &#8212; Function to load posix_time::time_period objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/posix_time/time_serialize.hpp&gt;   template&lt;typename Archive&gt;    void load(Archive &amp; ar, boost::posix_time::time_period &amp; tp, unsigned int);  Description time_period objects are broken down into 2 parts for serialization: a begining ptime object and an ending ptime object      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template loadhttps://www.boost.org/doc/libs/1_59_0/doc/load_idp107534384.html    Function template load           Home Libraries People FAQ More         Function template load load &#8212; Function to load nth_day_of_the_week_in_month objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void load(Archive &amp; ar, gregorian::nth_kday_of_month &amp; nkd, unsigned int);  Description nth_day_of_the_week_in_month objects are broken down into 3 parts for serialization: the week number, the day of the week, and the month      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template loadhttps://www.boost.org/doc/libs/1_59_0/doc/load_idp114906816.html    Function template load           Home Libraries People FAQ More         Function template load load &#8212; Function to load gregorian::date objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void load(Archive &amp; ar, ::boost::gregorian::date &amp; d, unsigned int);  Description Dates are serialized into a string for transport and storage. While it would be more efficient to store the internal integer used to manipulate the dates, it is an unstable solution.      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template loadhttps://www.boost.org/doc/libs/1_59_0/doc/load_idp115246992.html    Function template load           Home Libraries People FAQ More         Function template load load &#8212; Function to load gregorian::date_period objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void load(Archive &amp; ar, gregorian::date_period &amp; dp, unsigned int);  Description date_period objects are broken down into 2 parts for serialization: the begining date object and the end date object      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template loadhttps://www.boost.org/doc/libs/1_59_0/doc/load_idp46170624.html    Function template load           Home Libraries People FAQ More         Function template load load &#8212; Function to load gregorian::partial_date objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void load(Archive &amp; ar, gregorian::partial_date &amp; pd, unsigned int);  Description partial_date objects are broken down into 2 parts for serialization: the day (greg_day) and month (greg_month) objects      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template loadhttps://www.boost.org/doc/libs/1_59_0/doc/load_idp53474784.html    Function template load           Home Libraries People FAQ More         Function template load load &#8212; Function to load posix_time::time_duration objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/posix_time/time_serialize.hpp&gt;   template&lt;typename Archive&gt;    void load(Archive &amp; ar, posix_time::time_duration &amp; td, unsigned int);  Description time_duration objects are broken down into 4 parts for serialization: types are hour_type, min_type, sec_type, and fractional_seconds_type as defined in the time_duration class      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template loadhttps://www.boost.org/doc/libs/1_59_0/doc/load_idp53483920.html    Function template load           Home Libraries People FAQ More         Function template load load &#8212; Function to load posix_time::ptime objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/posix_time/time_serialize.hpp&gt;   template&lt;typename Archive&gt;    void load(Archive &amp; ar, posix_time::ptime &amp; pt, unsigned int);  Description ptime objects are broken down into 2 parts for serialization: a date object and a time_duration onject      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template loadhttps://www.boost.org/doc/libs/1_59_0/doc/load_idp68992240.html    Function template load           Home Libraries People FAQ More         Function template load load &#8212; Function to load last_day_of_the_week_in_month objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void load(Archive &amp; ar, gregorian::last_kday_of_month &amp; lkd, unsigned int);  Description last_day_of_the_week_in_month objects are broken down into 2 parts for serialization: the day of the week, and the month      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template loadhttps://www.boost.org/doc/libs/1_59_0/doc/load_idp71346736.html    Function template load           Home Libraries People FAQ More         Function template load load &#8212; Function to load first_day_of_the_week_in_month objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void load(Archive &amp; ar, gregorian::first_kday_of_month &amp; fkd, unsigned int);  Description first_day_of_the_week_in_month objects are broken down into 2 parts for serialization: the day of the week, and the month      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Chapter&#160;18.&#160;Boost.Lockfreehttps://www.boost.org/doc/libs/1_59_0/doc/lockfree.html    Chapter&#160;18.&#160;Boost.Lockfree           Home Libraries People FAQ More         Chapter&#160;18.&#160;Boost.Lockfree  Tim Blechmann  Copyright &#169; 2008-2011 Tim       Blechmann           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction &amp;     Motivation Examples Rationale  Data Structures Memory Management ABA Prevention Interprocess       Support  Reference  Header &lt;boost/lockfree/policies.hpp&gt; Header &lt;boost/lockfree/queue.hpp&gt; Header &lt;boost/lockfree/spsc_queue.hpp&gt; Header &lt;boost/lockfree/stack.hpp&gt;  Appendices  Supported       Platforms &amp; Compilers Future Developments References      Introduction &amp;     Motivation          Introduction       &amp; Terminology             The term non-blocking denotes concurrent data       structures, which do not use traditional synchronization primitives like guards       to ensure thread-safety. Maurice Herlihy and Nir Shavit (compare "The       Art of Multiprocessor Programming") distinguish between 3 types       of non-blocking data structures, each having different properties:                  data structures are wait-free, if every           concurrent operation is guaranteed to be finished in a finite number of           steps. It is therefore possible to give worst-case guarantees for the number           of operations.                     data structures are lock-free, if some           concurrent operations are guaranteed to be finished in a finite number           of steps. While it is in theory possible that some operations never make           any progress, it is very unlikely to happen in practical applications.                     data structures are obstruction-free,           if a concurrent operation is guaranteed to be finished in a finite number           of steps, unless another concurrent operation interferes.                  Some data structures can only be implemented in a lock-free manner, if they       are used under certain restrictions. The relevant aspects for the implementation       of boost.lockfree are the number of producer and consumer       threads. Single-producer (sp)       or multiple producer (mp)       means that only a single thread or multiple concurrent threads are allowed       to add data to a data structure. Single-consumer       (sc) or Multiple-consumer       (mc) denote the equivalent for the removal       of data from the data structure.              Properties       of Non-Blocking Data Structures             Non-blocking data structures do not rely on locks and mutexes to ensure thread-safety.       The synchronization is done completely in user-space without any direct interaction       with the operating system [4]. This implies that they are not prone to issues like priority inversion       (a low-priority thread needs to wait for a high-priority thread).             Instead of relying on guards, non-blocking data structures require atomic operations (specific CPU instructions executed       without interruption). This means that any thread either sees the state before       or after the operation, but no intermediate state can be observed. Not all       hardware supports the same set of atomic instructions. If it is not available       in hardware, it can be emulated in software using guards. However this has       the obvious drawback of losing the lock-free property.              Performance       of Non-Blocking Data Structures             When discussing the performance of non-blocking data structures, one has to       distinguish between amortized and worst-case costs. The definition of 'lock-free' and       'wait-free' only mention the upper bound of an operation. Therefore lock-free       data structures are not necessarily the best choice for every use case. In       order to maximise the throughput of an application one should consider high-performance       concurrent data structures [5].             Lock-free data structures will be a better choice in order to optimize the       latency of a system or to avoid priority inversion, which may be necessary       in real-time applications. In general we advise to consider if lock-free data       structures are necessary or if concurrent data structures are sufficient. In       any case we advice to perform benchmarks with different data structures for       a specific workload.              Sources       of Blocking Behavior             Apart from locks and mutexes (which we are not using in boost.lockfree       anyway), there are three other aspects, that could violate lock-freedom:         Atomic Operations              Some architectures do not provide the necessary atomic operations in             natively in hardware. If this is not the case, they are emulated in software             using spinlocks, which by itself is blocking.            Memory Allocations              Allocating memory from the operating system is not lock-free. This makes             it impossible to implement true dynamically-sized non-blocking data structures.             The node-based data structures of boost.lockfree use             a memory pool to allocate the internal nodes. If this memory pool is             exhausted, memory for new nodes has to be allocated from the operating             system. However all data structures of boost.lockfree             can be configured to avoid memory allocations (instead the specific calls             will fail). This is especially useful for real-time systems that require             lock-free memory allocations.            Exception Handling              The C++ exception handling does not give any guarantees about its real-time             behavior. We therefore do not encourage the use of exceptions and exception             handling in lock-free code.                      Data       Structures             boost.lockfree implements three lock-free data structures:         boost::lockfree::queue              a lock-free multi-produced/multi-consumer queue            boost::lockfree::stack              a lock-free multi-produced/multi-consumer stack            boost::lockfree::spsc_queue              a wait-free single-producer/single-consumer queue (commonly known as             ringbuffer)                      Data       Structure Configuration             The data structures can be configured with Boost.Parameter-style       templates:         boost::lockfree::fixed_sized              Configures the data structure as fixed sized.             The internal nodes are stored inside an array and they are addressed             by array indexing. This limits the possible size of the queue to the             number of elements that can be addressed by the index type (usually 2**16-2),             but on platforms that lack double-width compare-and-exchange instructions,             this is the best way to achieve lock-freedom.            boost::lockfree::capacity              Sets the capacity of a data structure             at compile-time. This implies that a data structure is fixed-sized.            boost::lockfree::allocator              Defines the allocator. boost.lockfree supports stateful             allocator and is compatible with Boost.Interprocess             allocators.                 [4]          Spinlocks do not directly interact with the operating system either. However         it is possible that the owning thread is preempted by the operating system,         which violates the lock-free property.        [5]          Intel's Thread Building         Blocks library provides many efficient concurrent data structures,         which are not necessarily lock-free.           Last revised: August 04, 2015 at 09:06:48 GMT         
Chapter&#160;19.&#160;Boost.Movehttps://www.boost.org/doc/libs/1_59_0/doc/move.html    Chapter&#160;19.&#160;Boost.Move           Home Libraries People FAQ More         Chapter&#160;19.&#160;Boost.Move  Ion Gaztanaga  Copyright &#169; 2008-2014 Ion Gaztanaga           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  What is Boost.Move? Introduction Implementing copyable     and movable classes  Copyable       and movable classes in C++0x Copyable       and movable classes in portable syntax for both C++03 and C++0x compilers  Composition or inheritance Movable but Non-Copyable Types Containers and move semantics Constructor Forwarding Implicit Move when returning a local     object Move iterators Move inserters Move algorithms Emulation limitations  Initializing       base classes Template       parameters for perfect forwarding Binding       of rvalue references to lvalues Assignment       operator in classes derived from or holding copyable and movable types  How the library works Thanks and credits Release Notes  Boost 1.59       Release Boost       1.58 Release Boost       1.57 Release Boost       1.56 Release Boost       1.55 Release Boost       1.54 Release Boost       1.53 Release Boost       1.51 Release Boost       1.49 Release  Reference  Header &lt;boost/move/adl_move_swap.hpp&gt; Header &lt;boost/move/algorithm.hpp&gt; Header &lt;boost/move/core.hpp&gt; Header &lt;boost/move/default_delete.hpp&gt; Header &lt;boost/move/iterator.hpp&gt; Header &lt;boost/move/make_unique.hpp&gt; Header &lt;boost/move/move.hpp&gt; Header &lt;boost/move/traits.hpp&gt; Header &lt;boost/move/unique_ptr.hpp&gt; Header &lt;boost/move/utility.hpp&gt; Header &lt;boost/move/utility_core.hpp&gt;       Important         To be able to use containers of movable-only values you will need to use containers       supporting move semantics, like Boost.Container       containers          Note         Tested compilers: MSVC-7.1, 8.0, 9.0, GCC 4.3-MinGW in C++03 and C++0x modes,       Intel 10.1         What is Boost.Move?         Rvalue references are a major C++0x feature, enabling move semantics for C++       values. However, we don't need C++0x compilers to take advantage of move semanatics.       Boost.Move emulates C++0x move semantics in       C++03 compilers and allows writing portable code that works optimally in C++03       and C++0x compilers.         Last revised: August 04, 2015 at 09:06:49 GMT         
Chapter&#160;20.&#160;Boost.MPIhttps://www.boost.org/doc/libs/1_59_0/doc/mpi.html    Chapter&#160;20.&#160;Boost.MPI           Home Libraries People FAQ More         Chapter&#160;20.&#160;Boost.MPI  Douglas Gregor   Matthias Troyer  Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )           Table of Contents  Introduction Getting started  MPI Implementation Configure and Build Using Boost.MPI  Tutorial  Point-to-Point communication Collective operations Managing communicators Separating structure from content Performance optimizations Mapping from C MPI to Boost.MPI  Reference  Header &lt;boost/mpi.hpp&gt; Header &lt;boost/mpi/allocator.hpp&gt; Header &lt;boost/mpi/collectives.hpp&gt; Header &lt;boost/mpi/collectives_fwd.hpp&gt; Header &lt;boost/mpi/communicator.hpp&gt; Header &lt;boost/mpi/config.hpp&gt; Header &lt;boost/mpi/datatype.hpp&gt; Header &lt;boost/mpi/datatype_fwd.hpp&gt; Header &lt;boost/mpi/environment.hpp&gt; Header &lt;boost/mpi/exception.hpp&gt; Header &lt;boost/mpi/graph_communicator.hpp&gt; Header &lt;boost/mpi/group.hpp&gt; Header &lt;boost/mpi/inplace.hpp&gt; Header &lt;boost/mpi/intercommunicator.hpp&gt; Header &lt;boost/mpi/nonblocking.hpp&gt; Header &lt;boost/mpi/operations.hpp&gt; Header &lt;boost/mpi/packed_iarchive.hpp&gt; Header &lt;boost/mpi/packed_oarchive.hpp&gt; Header &lt;boost/mpi/python.hpp&gt; Header &lt;boost/mpi/request.hpp&gt; Header &lt;boost/mpi/skeleton_and_content.hpp&gt; Header &lt;boost/mpi/skeleton_and_content_fwd.hpp&gt; Header &lt;boost/mpi/status.hpp&gt; Header &lt;boost/mpi/timer.hpp&gt;  Python Bindings  Quickstart Transmitting User-Defined Data Collectives Skeleton/Content Mechanism Design Philosophy Threads Performance Evaluation Revision History Acknowledgments      Introduction        Boost.MPI is a library for message passing in high-performance parallel applications.       A Boost.MPI program is one or more processes that can communicate either via       sending and receiving individual messages (point-to-point communication) or       by coordinating as a group (collective communication). Unlike communication       in threaded environments or using a shared-memory library, Boost.MPI processes       can be spread across many different machines, possibly with different operating       systems and underlying architectures.             Boost.MPI is not a completely new parallel programming library. Rather, it       is a C++-friendly interface to the standard Message Passing Interface (MPI), the most popular library       interface for high-performance, distributed computing. MPI defines a library       interface, available from C, Fortran, and C++, for which there are many MPI implementations.       Although there exist C++ bindings for MPI, they offer little functionality       over the C bindings. The Boost.MPI library provides an alternative C++ interface       to MPI that better supports modern C++ development styles, including complete       support for user-defined data types and C++ Standard Library types, arbitrary       function objects for collective algorithms, and the use of modern C++ library       techniques to maintain maximal efficiency.             At present, Boost.MPI supports the majority of functionality in MPI 1.1. The       thin abstractions in Boost.MPI allow one to easily combine it with calls to       the underlying C MPI library. Boost.MPI currently supports:                  Communicators: Boost.MPI supports the creation, destruction, cloning, and           splitting of MPI communicators, along with manipulation of process groups.                     Point-to-point communication: Boost.MPI supports point-to-point communication           of primitive and user-defined data types with send and receive operations,           with blocking and non-blocking interfaces.                     Collective communication: Boost.MPI supports collective operations such           as reduce           and gather           with both built-in and user-defined data types and function objects.                     MPI Datatypes: Boost.MPI can build MPI data types for user-defined types           using the Boost.Serialization           library.                     Separating structure from content: Boost.MPI can transfer the shape (or           "skeleton") of complexc data structures (lists, maps, etc.) and           then separately transfer their content. This facility optimizes for cases           where the data within a large, static data structure needs to be transmitted           many times.                  Boost.MPI can be accessed either through its native C++ bindings, or through       its alternative, Python interface.         Last revised: August 04, 2015 at 09:06:49 GMT         
Macro MPICH_IGNORE_CXX_SEEKhttps://www.boost.org/doc/libs/1_59_0/doc/MPICH_IGNORE_CXX_SEEK.html    Macro MPICH_IGNORE_CXX_SEEK           Home Libraries People FAQ More         Macro MPICH_IGNORE_CXX_SEEK MPICH_IGNORE_CXX_SEEK  Synopsis // In header: &lt;boost/mpi/config.hpp&gt;  MPICH_IGNORE_CXX_SEEK    Copyright &#169; 2005-2007 Douglas Gregor,       Matthias Troyer, Trustees of Indiana University         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )                
Concept ObjectTransformhttps://www.boost.org/doc/libs/1_59_0/doc/ObjectTransform.html    Concept ObjectTransform           Home Libraries People FAQ More         Concept ObjectTransform ObjectTransform   Description        An ObjectTransform is a function type or a function       pointer type where the return type Obj is a       an object type and the arguments are       Transforms. is_callable&lt; Obj &gt;::value       must be false. The ObjectTransform, when applied,       has the effect of constructing an object of type       Obj' (see below), passing as construction parameters       the result(s) of applying transform(s) Tn.             The type Obj may be a template specialization representing       a compile-time lambda expression. For instance, if Obj is       std::pair&lt; proto::_value, int &gt;, the result type of the       ObjectTransform is computed by replacing the type proto::_value       with the result of applying the proto::_value transform. For       given types Obj, Expr, State and Data, we can say that the       type Obj' represents the type Obj after all nested transforms       have been replaced with the results of applying the transforms       with Expr, State and Data as transform arguments.             If the type Obj is not a template specialization representing       a compile-time lambda expression, then the result type Obj' is       the same as Obj.        Notation  Obj A type playing the role of object-type in the ObjectTransform concept. Tn A type playing the role of transform-type in the ObjectTransform concept. Expr A type playing the role of expression-type in the ObjectTransform concept. State A type playing the role of state-type in the ObjectTransform concept. Data A type playing the role of data-type in the ObjectTransform concept. expr Object of type Expr state Object of type State data Object of type Data    Valid expressions         Name Expression Type Semantics   Apply Transform when&lt; _, Obj(Tn...)&gt;()(expr, state, data) Obj' Applies the transform.     Models std::pair&lt; boost::proto::_value, int &gt;(boost::proto::_value, int())     Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Concept PolymorphicFunctionObjecthttps://www.boost.org/doc/libs/1_59_0/doc/PolymorphicFunctionObject.html    Concept PolymorphicFunctionObject           Home Libraries People FAQ More         Concept PolymorphicFunctionObject PolymorphicFunctionObject   Description        A type that can be called and that follows the TR1 ResultOf       protocol for return type calculation.        Associated types  result_type result_of&lt;Fn(A0,...An)&gt;::type         The result of calling the Polymorphic Function Object.          Notation  Fn A type playing the role of polymorphic-function-object-type in the PolymorphicFunctionObject concept. fn Object of type Fn a0,...an Object of type A0,...An    Valid expressions         Name Expression Type Semantics   Function Call fn(a0,...an) result_type Calls the function object.     Models std::plus&lt;int&gt;     Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Concept PrimitiveTransformhttps://www.boost.org/doc/libs/1_59_0/doc/PrimitiveTransform.html    Concept PrimitiveTransform           Home Libraries People FAQ More         Concept PrimitiveTransform PrimitiveTransform   Description        A PrimitiveTransform is a class type that       has a nested class template called       impl&lt;&gt; that takes       three template parameters representing an expression       type, a state type and a data type. Specializations       of the nested impl template are ternary monomorphic       function objects that accept expression, state, and       data parameters. A PrimitiveTransform is also a       PolymorphicFunctionObject       implemented in terms of the nested       impl&lt;&gt; template.        Associated types  result_type typename Fn::template impl&lt;Expr, State, Data&gt;::result_type         The return type of the overloaded function call operator.          Notation  Fn A type playing the role of primitive-transform-type in the PrimitiveTransform concept. Expr A type playing the role of expression-type in the PrimitiveTransform concept. State A type playing the role of state-type in the PrimitiveTransform concept. Data A type playing the role of data-type in the PrimitiveTransform concept. fn Object of type Fn expr Object of type Expr state Object of type State data Object of type Data    Valid expressions         Name Expression Type Semantics    Polymorphic Function Call 1 fn(expr) result_type Applies the transform.   Polymorphic Function Call 2 fn(expr, state) result_type Applies the transform.   Polymorphic Function Call 3 fn(expr, state, data) result_type Applies the transform.   Monomorphic Function Call typename Fn::template impl&lt; Expr, State, Data &gt;()(expr, state, data) result_type Applies the transform.      Models boost::proto::_child_c&lt; 0 &gt;     Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Chapter&#160;21.&#160;Boost.Program_optionshttps://www.boost.org/doc/libs/1_59_0/doc/program_options.html    Chapter&#160;21.&#160;Boost.Program_options           Home Libraries People FAQ More         Chapter&#160;21.&#160;Boost.Program_options  Vladimir Prus  Copyright &#169; 2002-2004 Vladimir Prus  Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Tutorial  Getting Started Option Details Multiple Sources  Library Overview  Options Description Component Parsers Component Storage Component Specific parsers Annotated List of Symbols  How To  Non-conventional Syntax Response Files Winmain Command Line Option Groups and Hidden Options Custom Validators Unicode Support Allowing Unknown Options  Design Discussion Unicode Support Acknowledgements Reference  Header &lt;boost/program_options/cmdline.hpp&gt; Header &lt;boost/program_options/config.hpp&gt; Header &lt;boost/program_options/environment_iterator.hpp&gt; Header &lt;boost/program_options/eof_iterator.hpp&gt; Header &lt;boost/program_options/errors.hpp&gt; Header &lt;boost/program_options/option.hpp&gt; Header &lt;boost/program_options/options_description.hpp&gt; Header &lt;boost/program_options/parsers.hpp&gt; Header &lt;boost/program_options/positional_options.hpp&gt; Header &lt;boost/program_options/value_semantic.hpp&gt; Header &lt;boost/program_options/variables_map.hpp&gt; Header &lt;boost/program_options/version.hpp&gt;      Introduction The program_options library allows program developers to obtain     program options, that is (name, value) pairs from the user,     via conventional methods such as command line and config file. Why would you use such a library, and why is it better than parsing     your command line by straightforward hand-written code?         It's easier. The syntax for declaring options is simple, and           the library itself is small. Things like conversion of option values to           desired type and storing into program variables are handled           automatically.            Error reporting is better. All the problems with the command line are             reported, while hand-written code can just misparse the input. In             addition, the usage message can be automatically generated, to             avoid falling out of sync with the real list of options. Options can be read from anywhere. Sooner or later the command           line will be not enough for your users, and you'll want config files           or maybe even environment variables. These can be added without significant            effort on your part.                          Now let's see some examples of the library usage in the the section called &#8220;Tutorial&#8221;.                  
Chapter&#160;22.&#160;Boost.PropertyTreehttps://www.boost.org/doc/libs/1_59_0/doc/property_tree.html    Chapter&#160;22.&#160;Boost.PropertyTree           Home Libraries People FAQ More         Chapter&#160;22.&#160;Boost.PropertyTree  Marcin Kalicinski   Sebastian Redl  Copyright &#169; 2008-2010 Marcin Kalicinski Copyright &#169; 2010-2013 Sebastian       Redl           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  What is Property Tree? Five Minute Tutorial Property Tree as a Container Property Tree Synopsis How to Populate a Property Tree  XML Parser JSON Parser INI Parser INFO Parser  How to Access Data in a Property     Tree Appendices Reference  Header &lt;boost/property_tree/exceptions.hpp&gt; Header &lt;boost/property_tree/id_translator.hpp&gt; Header &lt;boost/property_tree/info_parser.hpp&gt; Header &lt;boost/property_tree/ini_parser.hpp&gt; Header &lt;boost/property_tree/json_parser.hpp&gt; Header &lt;boost/property_tree/ptree.hpp&gt; Header &lt;boost/property_tree/ptree_fwd.hpp&gt; Header &lt;boost/property_tree/ptree_serialization.hpp&gt; Header &lt;boost/property_tree/stream_translator.hpp&gt; Header &lt;boost/property_tree/string_path.hpp&gt; Header &lt;boost/property_tree/xml_parser.hpp&gt;      What is Property Tree?         The Property Tree library provides a data structure that stores an arbitrarily       deeply nested tree of values, indexed at each level by some key. Each node       of the tree stores its own value, plus an ordered list of its subnodes and       their keys. The tree allows easy access to any of its nodes by means of a path,       which is a concatenation of multiple keys.             In addition, the library provides parsers and generators for a number of data       formats that can be represented by such a tree, including XML, INI, and JSON.             Property trees are versatile data structures, but are particularly suited for       holding configuration data. The tree provides its own, tree-specific interface,       and each node is also an STL-compatible Sequence for its child nodes.             Conceptually, then, a node can be thought of as the following structure:      struct ptree {    data_type data;                         // data associated with the node    list&lt; pair&lt;key_type, ptree&gt; &gt; children; // ordered list of named children };         Both key_type and data_type are configurable to some extent, but will usually       be std::string or std::wstring, and the parsers only work with this kind of       tree.             Many software projects develop a similar tool at some point of their lifetime,       and property tree originated the same way. We hope the library can save many       from reinventing the wheel.         Last revised: August 04, 2015 at 09:06:56 GMT         
Chapter&#160;23.&#160;Boost.Protohttps://www.boost.org/doc/libs/1_59_0/doc/proto.html    Chapter&#160;23.&#160;Boost.Proto           Home Libraries People FAQ More         Chapter&#160;23.&#160;Boost.Proto  Eric Niebler  Copyright &#169; 2008 Eric Niebler           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Preface Users' Guide  Getting Started Fronts Ends: Defining       Terminals and Non-Terminals of Your EDSL Intermediate       Form: Understanding and Introspecting Expressions Back Ends: Making Expression       Templates Do Useful Work Examples Background and Resources Glossary  Reference  Concepts Classes Functions Header &lt;boost/proto/args.hpp&gt; Header &lt;boost/proto/core.hpp&gt; Header &lt;boost/proto/debug.hpp&gt; Header &lt;boost/proto/deep_copy.hpp&gt; Header &lt;boost/proto/domain.hpp&gt; Header &lt;boost/proto/eval.hpp&gt; Header &lt;boost/proto/expr.hpp&gt; Header &lt;boost/proto/extends.hpp&gt; Header &lt;boost/proto/functional.hpp&gt; Header &lt;boost/proto/functional/fusion.hpp&gt; Header &lt;boost/proto/functional/fusion/at.hpp&gt; Header &lt;boost/proto/functional/fusion/pop_back.hpp&gt; Header &lt;boost/proto/functional/fusion/pop_front.hpp&gt; Header &lt;boost/proto/functional/fusion/push_back.hpp&gt; Header &lt;boost/proto/functional/fusion/push_front.hpp&gt; Header &lt;boost/proto/functional/fusion/reverse.hpp&gt; Header &lt;boost/proto/functional/range/begin.hpp&gt; Header &lt;boost/proto/functional/range/empty.hpp&gt; Header &lt;boost/proto/functional/range/end.hpp&gt; Header &lt;boost/proto/functional/range/rbegin.hpp&gt; Header &lt;boost/proto/functional/range/rend.hpp&gt; Header &lt;boost/proto/functional/range/size.hpp&gt; Header &lt;boost/proto/functional/std.hpp&gt; Header &lt;boost/proto/functional/std/iterator.hpp&gt; Header &lt;boost/proto/functional/std/utility.hpp&gt; Header &lt;boost/proto/fusion.hpp&gt; Header &lt;boost/proto/generate.hpp&gt; Header &lt;boost/proto/literal.hpp&gt; Header &lt;boost/proto/make_expr.hpp&gt; Header &lt;boost/proto/matches.hpp&gt; Header &lt;boost/proto/operators.hpp&gt; Header &lt;boost/proto/proto.hpp&gt; Header &lt;boost/proto/proto_fwd.hpp&gt; Header &lt;boost/proto/proto_typeof.hpp&gt; Header &lt;boost/proto/repeat.hpp&gt; Header &lt;boost/proto/tags.hpp&gt; Header &lt;boost/proto/traits.hpp&gt; Header &lt;boost/proto/transform.hpp&gt; Header &lt;boost/proto/transform/arg.hpp&gt; Header &lt;boost/proto/transform/call.hpp&gt; Header &lt;boost/proto/transform/default.hpp&gt; Header &lt;boost/proto/transform/env.hpp&gt; Header &lt;boost/proto/transform/fold.hpp&gt; Header &lt;boost/proto/transform/fold_tree.hpp&gt; Header &lt;boost/proto/transform/impl.hpp&gt; Header &lt;boost/proto/transform/integral_c.hpp&gt; Header &lt;boost/proto/transform/lazy.hpp&gt; Header &lt;boost/proto/transform/make.hpp&gt; Header &lt;boost/proto/transform/pass_through.hpp&gt; Header &lt;boost/proto/transform/when.hpp&gt; Header &lt;boost/proto/context.hpp&gt; Header &lt;boost/proto/context/callable.hpp&gt; Header &lt;boost/proto/context/default.hpp&gt; Header &lt;boost/proto/context/null.hpp&gt;  Appendices  Appendix A: Release       Notes Appendix B: History Appendix C: Rationale Appendix D: Implementation       Notes Appendix E:       Acknowledgements      Preface           &#8220;There are more things in heaven and earth, Horatio, than are dreamt         of in your philosophy.&#8221;                 -- William Shakespeare                Description             Proto is a framework for building Embedded Domain-Specific Languages in C++.       It provides tools for constructing, type-checking, transforming and executing       expression templates[6]. More specifically, Proto provides:                  An expression tree data structure.                     A mechanism for giving expressions additional behaviors and members.                     Operator overloads for building the tree from an expression.                     Utilities for defining the grammar to which an expression must conform.                     An extensible mechanism for immediately executing an expression template.                     An extensible set of tree transformations to apply to expression trees.                   Motivation             Expression Templates are an advanced technique that C++ library developers       use to define embedded mini-languages that target specific problem domains.       The technique has been used to create efficient and easy-to-use libraries for       linear algebra as well as to define C++ parser generators with a readable syntax.       But developing such a library involves writing an inordinate amount of unreadable       and unmaintainable template mumbo-jumbo. Boost.Proto eases the development       of domain-specific embedded       languages (EDSLs). Use Proto to define the primitives of your mini-language       and let Proto handle the operator overloading and the construction of the expression       parse tree. Immediately evaluate the expression tree by passing it a function       object. Or transform the expression tree by defining the grammar of your mini-language,       decorated with an assortment of tree transforms provided by Proto or defined       by you. Then use the grammar to give your users short and readable syntax errors       for invalid expressions! No more mumbo-jumbo -- an expression template library       developed with Proto is declarative and readable.             In short, Proto is an EDSL for defining EDSLs.              How       to Use This Documentation             This documentation makes use of the following naming and formatting conventions.                  Code is in fixed width           font and is syntax-highlighted.                     Replaceable text that you will need to supply is in italics.                     If a name refers to a free function, it is specified like this: free_function();           that is, it is in code font and its name is followed by ()           to indicate that it is a free function.                     If a name refers to a class template, it is specified like this: class_template&lt;&gt;;           that is, it is in code font and its name is followed by &lt;&gt;           to indicate that it is a class template.                     If a name refers to a function-like macro, it is specified like this:           MACRO();           that is, it is uppercase in code font and its name is followed by () to indicate that it is a function-like           macro. Object-like macros appear without the trailing ().                     Names that refer to concepts in the generic programming           sense are specified in CamelCase.              Note           In addition, notes such as this one specify non-essential information that         provides additional background or rationale.                Finally, you can mentally add the following to any code fragments in this document:      // Include all of Proto #include &lt;boost/proto/proto.hpp&gt;  // Create some namespace aliases namespace mpl = boost::mpl; namespace fusion = boost::fusion; namespace proto = boost::proto;  // Allow unqualified use of Proto's wildcard pattern using proto::_;     [6]          See Expression         Templates           Last revised: August 04, 2015 at 09:06:56 GMT         
Chapter&#160;41.&#160;Quickbook 1.6https://www.boost.org/doc/libs/1_59_0/doc/quickbook.html    Chapter&#160;41.&#160;Quickbook 1.6           Home Libraries People FAQ More         Chapter&#160;41.&#160;Quickbook 1.6   Joel de Guzman   Eric Niebler   Copyright &#169; 2002, 2004, 2006 Joel de Guzman,       Eric Niebler Copyright &#169; 2010, 2011 Daniel James           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Change Log Syntax Summary Comments Document Structure  Document       Info Sections  Phrase Level Elements  Font       Styles Replaceable Quotations Simple       formatting Role Inline       code Code       blocks Source       Mode line-break Anchors Links Anchor       links refentry       links Code       Links Escape Single       char escape Unicode       escape Images Footnotes Macro       Expansion Template       Expansion Conditional       Generation  Block Level Elements  xinclude Paragraphs Lists Code Escaping       Back To QuickBook Preformatted Blockquote Admonitions Headings Generic       Heading Macros Predefined       Macros Templates Blurbs Tables Variable       Lists Include Import Plain       blocks  Language Versions  Stable Versions Quickbook 1.6 Quickbook 1.7  Installation and configuration  Mac OS X Windows 2000, XP, 2003, Vista,       7 Debian, Ubuntu  Editor Support  Scintilla Text Editor KDE Support  Frequently Asked Questions Quick Reference     Introduction           &#8220;Why program by hand in five days what         you can spend five years of your life automating?&#8221;                 -- Terrence Parr, author ANTLR/PCCTS                Well, QuickBook started as a weekend hack. It was originally intended to be       a sample application using Spirit.       What is it? What you are viewing now, this documentation, is autogenerated       by QuickBook. These files were generated from one master:               quickbook.qbk               Originally named QuickDoc, this funky tool that never dies, evolved into a       funkier tool thanks to Eric Niebler who resurrected the project making it generate       BoostBook       instead of HTML. The BoostBook       documentation format is an extension of DocBook,       an SGML or XML based format for describing documentation.         Tip           You don't need to know anything about BoostBook         or DocBook to use QuickBook.         A basic understanding of DocBook         might help, but shouldn't be necessary. For really advanced stuff you will         need to know DocBook, but you         can ignore it at first, and maybe continue to do so.                QuickBook is a WikiWiki style documentation tool geared towards C++ documentation       using simple rules and markup for simple formatting tasks. QuickBook extends       the WikiWiki concept. Like the WikiWiki, QuickBook documents are simple text       files. A single QuickBook document can generate a fully linked set of nice       HTML and PostScript/PDF documents complete with images and syntax- colorized       source code.             Features include:                  generate BoostBook           xml, to generate HTML, PostScript and PDF                     simple markup to link to Doxygen-generated entities                     macro system for simple text substitution                     simple markup for italics, bold, preformatted, blurbs, code samples, tables,           URLs, anchors, images, etc.                     automatic syntax coloring of code samples                     CSS support                       
Chapter&#160;25.&#160;Boost.Ratio 2.1.0https://www.boost.org/doc/libs/1_59_0/doc/ratio.html    Chapter&#160;25.&#160;Boost.Ratio 2.1.0           Home Libraries People FAQ More         Chapter&#160;25.&#160;Boost.Ratio 2.1.0  Howard Hinnant   Beman Dawes   Vicente J. Botet Escriba  Copyright &#169; 2008 Howard Hinnant Copyright &#169; 2006, 2008 Beman Dawes Copyright &#169; 2009-2012 Vicente       J. Botet Escriba           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Overview  Motivation Description  User's Guide  Getting Started Tutorial Example External Resources  Reference   Header &lt;boost/ratio/config.hpp&gt; C++0x Recommendation Ratio I/O Rational Constant  Appendices  Appendix A: History Appendix B: Rationale Appendix C: Implementation       Notes Appendix D: FAQ Appendix E: Acknowledgements Appendix F: Tests Appendix G: Tickets Appendix H: Future Plans      Overview   Motivation Description          How       to Use This Documentation             This documentation makes use of the following naming and formatting conventions.                  Code is in fixed width           font and is syntax-highlighted.                     Replaceable text that you will need to supply is in italics.                     Free functions are rendered in the code font followed by (), as in free_function().                     If a name refers to a class template, it is specified like this: class_template&lt;&gt;;           that is, it is in code font and its name is followed by &lt;&gt;           to indicate that it is a class template.                     If a name refers to a function-like macro, it is specified like this:           MACRO();           that is, it is uppercase in code font and its name is followed by () to indicate that it is a function-like           macro. Object-like macros appear without the trailing ().                     Names that refer to concepts in the generic programming           sense are specified in CamelCase.              Note           In addition, notes such as this one specify non-essential information that         provides additional background or rationale.                Finally, you can mentally add the following to any code fragments in this document:      // Include all of Ratio files #include &lt;boost/ratio.hpp&gt; using namespace boost;    Motivation           Boost.Ratio aims to implement the compile         time ratio facility in C++0x, as proposed in N2661 - A Foundation to Sleep On. That document         provides background and motivation for key design decisions and is the source         of a good deal of information in this documentation.           Description           The Boost.Ratio library provides:                      A class template, ratio, for specifying compile             time rational constants such as 1/3 of a nanosecond or the number of             inches per meter. ratio represents a compile time             ratio of compile time constants with support for compile time arithmetic             with overflow and division by zero protection.                         It provides a textual representation of boost::ratio&lt;N, D&gt; in the form of a std::basic_string             which can be useful for I/O.                         Some extension related to the Rational             Constant concept enabling the use of ratio&lt;&gt; in the context             of Boost.MPL numeric metafunctions.                 Last revised: August 04, 2015 at 09:07:21 GMT         
Redirect to generated documentationhttps://www.boost.org/doc/libs/1_59_0/doc/ref.html               Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at       http://www.boost.org/LICENSE_1_0.txt) -->     Redirect to generated documentation                Automatic redirection failed, please go to     http://www.boost.org/doc/libs/master/doc/html/ref.html     
Referencehttps://www.boost.org/doc/libs/1_59_0/doc/reference.html    Reference           Home Libraries People FAQ More        Reference Elements:  Element access - Declares an access specification for class members Element boostbook - Defines a BoostBook book Element class - Declares a class or class template Element class-specialization - A specialization (partial or full) of a class template Element code - Mimics the code tag in HTML Element compile-fail-test - A testcase that should fail to compile Element compile-test - A testcase that should compile correctly Element complexity - The time/space/etc. complexity of a function Element constructor - Declares a constructor of the enclosing class Element copy-assignment - Declares a copy-assignment operator Element data-member - Declares a data member of a class Element default - The default value of a function or template parameter Element description - Detailed description of a construct Element destructor - Declares a destructor for the enclosing class Element effects - Declares the side effects of a function Element enum - Declares an enumeration type Element enumname - References an enumeration type with the given name Element enumvalue - A single value of an enumeration Element free-function-group - A set of functions that are grouped together under one name Element function - Declares a function Element functionname - References a function with the given name Element globalname - References a global with the given name Element header - Declares a C++ header with the given name Element headername - References a C++ header with the given name Element if-fails - What it means when a testcase fails Element inherit - Declares a base class of the enclosing class or struct Element lib - A library dependency Element library - Top-level element for a library Element library-reference - Declares the reference material for a library Element librarycategory - Declares that the enclosing library is in this category Element librarycategorydef - Defines a new library category Element librarycategorylist - Categorized listing of libraries Element libraryinfo - Provides information about a library Element librarylist - Placeholder for an alphabetical list of libraries Element libraryname - References a library of the given name Element librarypurpose - Describes in one short sentence or phrase the purpose of a library Element link-fail-test - Declares a test that should compile but fail to link Element link-test - Declares a test that should compile and link Element macroname - References a macro with the given name Element method - Declares a method, i.e., a member function Element method-group - A set of methods that are grouped together under one name Element namespace - Declares a namespace Element notes - Non-normative notes about a function's semantics Element overloaded-function - An overloaded function Element overloaded-method - An overloaded method Element parameter - A function parameter Element paramtype - The type of a function parameter Element postconditions - Conditions that must hold after the function returns Element precondition - Conditions that must be met prior to executing a function Element programlisting - A sample of program code Element purpose - A short description of an entity's use Element rationale - Describes the rationale for a particular function's design Element requirement - A requirement/property in the Jamfile for a testcase Element requires - Declares the requirements of a function Element returns - Description of the return value of a function Element run-fail-test - A testcase that should compile and link, but fail on execution Element run-test - A testcase that should compile, link, and execute Element signature - One signature of an overloaded function or method Element snippet - Pulls in a code snippet from a programlisting element Element source - Defines source code for a test Element specialization - Defines the specialization arguments for a class specialization Element static-constant - Declares a static constant, e.g., const int foo = 5;. Element struct - Declares a C++ struct Element struct-specialization - A specialization (full or partial) of a struct template Element template - Declares the template parameters of a class or function Element template-arg - A template argument in a specialization Element template-nontype-parameter - A nontype template parameter Element template-type-parameter - Declares a template type parameter Element template-varargs - Declares a variable-length list of template parameters Element testsuite - Describes a library testsuite Element throws - Description of the exceptions thrown by a function Element type - The type of an element or return type of a function Element typedef - Declares a typedef Element union - Declares a C++ union or union template Element union-specialization - A specialization (full or partial) of a union template Element using-class - Injects the method and function names of a class into the local scope Element using-namespace - Injects the declared names from a namespace into the local scope     Copyright &#169; 2003-2005 Douglas GregorDistributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at       http://www.boost.org/LICENSE_1_0.txt).                
Function template savehttps://www.boost.org/doc/libs/1_59_0/doc/save_idp103065216.html    Function template save           Home Libraries People FAQ More         Function template save save &#8212; Function to save posix_time::time_period objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/posix_time/time_serialize.hpp&gt;   template&lt;typename Archive&gt;    void save(Archive &amp; ar, const posix_time::time_period &amp; tp, unsigned int);  Description time_period objects are broken down into 2 parts for serialization: a begining ptime object and an ending ptime object      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template savehttps://www.boost.org/doc/libs/1_59_0/doc/save_idp107529808.html    Function template save           Home Libraries People FAQ More         Function template save save &#8212; Function to save nth_day_of_the_week_in_month objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void save(Archive &amp; ar, const gregorian::nth_kday_of_month &amp; nkd,              unsigned int);  Description nth_day_of_the_week_in_month objects are broken down into 3 parts for serialization: the week number, the day of the week, and the month      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template savehttps://www.boost.org/doc/libs/1_59_0/doc/save_idp115242448.html    Function template save           Home Libraries People FAQ More         Function template save save &#8212; Function to save gregorian::date_period objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void save(Archive &amp; ar, const gregorian::date_period &amp; dp, unsigned int);  Description date_period objects are broken down into 2 parts for serialization: the begining date object and the end date object      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template savehttps://www.boost.org/doc/libs/1_59_0/doc/save_idp46166048.html    Function template save           Home Libraries People FAQ More         Function template save save &#8212; Function to save gregorian::partial_date objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void save(Archive &amp; ar, const gregorian::partial_date &amp; pd, unsigned int);  Description partial_date objects are broken down into 2 parts for serialization: the day (typically greg_day) and month (typically greg_month) objects      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template savehttps://www.boost.org/doc/libs/1_59_0/doc/save_idp53479392.html    Function template save           Home Libraries People FAQ More         Function template save save &#8212; Function to save posix_time::ptime objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/posix_time/time_serialize.hpp&gt;   template&lt;typename Archive&gt;    void save(Archive &amp; ar, const posix_time::ptime &amp; pt, unsigned int);  Description ptime objects are broken down into 2 parts for serialization: a date object and a time_duration onject      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template savehttps://www.boost.org/doc/libs/1_59_0/doc/save_idp68987680.html    Function template save           Home Libraries People FAQ More         Function template save save &#8212; Function to save last_day_of_the_week_in_month objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void save(Archive &amp; ar, const gregorian::last_kday_of_month &amp; lkd,              unsigned int);  Description last_day_of_the_week_in_month objects are broken down into 2 parts for serialization: the day of the week, and the month      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template savehttps://www.boost.org/doc/libs/1_59_0/doc/save_idp71342176.html    Function template save           Home Libraries People FAQ More         Function template save save &#8212; Function to save first_day_of_the_week_in_month objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void save(Archive &amp; ar, const gregorian::first_kday_of_month &amp; fkd,              unsigned int);  Description first_day_of_the_week_in_month objects are broken down into 2 parts for serialization: the day of the week, and the month      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Function template savehttps://www.boost.org/doc/libs/1_59_0/doc/save_idp99566704.html    Function template save           Home Libraries People FAQ More         Function template save save &#8212; Function to save gregorian::date objects using serialization lib.   Synopsis // In header: &lt;boost/date_time/gregorian/greg_serialize.hpp&gt;   template&lt;typename Archive&gt;    void save(Archive &amp; ar, const ::boost::gregorian::date &amp; d, unsigned int);  Description Dates are serialized into a string for transport and storage. While it would be more efficient to store the internal integer used to manipulate the dates, it is an unstable solution.      Copyright &#169; 2001-2005 CrystalClear Software, IncSubject to the Boost Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)         
Chapter&#160;26.&#160;Boost.Signalshttps://www.boost.org/doc/libs/1_59_0/doc/signals.html    Chapter&#160;26.&#160;Boost.Signals           Home Libraries People FAQ More         Chapter&#160;26.&#160;Boost.Signals  Douglas Gregor  Copyright &#169; 2001-2004 Douglas Gregor  Use, modification and distribution is subject to the Boost     Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)    Table of Contents  Introduction Tutorial  How to Read this Tutorial Compatibility Note Hello, World! (Beginner) Calling multiple slots Passing values to and from slots Connection Management Example: Document-View Linking against the Signals library  Reference  Header &lt;boost/signal.hpp&gt; Header &lt;boost/signals/slot.hpp&gt; Header &lt;boost/signals/trackable.hpp&gt; Header &lt;boost/signals/connection.hpp&gt; Header &lt;boost/visit_each.hpp&gt; Header &lt;boost/last_value.hpp&gt;  Frequently Asked Questions Design Overview  Type Erasure connection class Slot Call Iterator visit_each function template  Design Rationale  Choice of Slot Definitions User-level Connection Management Combiner Interface Connection Interfaces: +=  operator trackable rationale Comparison with other Signal/Slot implementations  Testsuite Acceptance tests     Introduction    Note  Boost.Signals is no longer being actively maintained. Do not use Boost.Signals for new development (use  Boost.Signals2 instead). If you have existing Boost.Signals-based code, it will continue to work, but consider moving to Boost.Signals2. There is  a porting guide in the Signals2 documentation.  The Boost.Signals library is an implementation of a managed signals and slots system. Signals represent callbacks with multiple targets, and are also called publishers or events in similar systems. Signals are connected to some set of slots, which are callback receivers (also called event targets or subscribers), which are called when the signal is "emitted." Signals and slots are managed, in that signals and slots (or, more properly, objects that occur as part of the slots) track all connections and are capable of automatically disconnecting signal/slot connections when either is destroyed. This enables the user to make signal/slot connections without expending a great effort to manage the lifetimes of those connections with regard to the lifetimes of all objects involved. When signals are connected to multiple slots, there is a question regarding the relationship between the return values of the slots and the return value of the signals. Boost.Signals allows the user to specify the manner in which multiple return values are combined.             
Chapter&#160;27.&#160;Boost.Signals2https://www.boost.org/doc/libs/1_59_0/doc/signals2.html    Chapter&#160;27.&#160;Boost.Signals2           Home Libraries People FAQ More         Chapter&#160;27.&#160;Boost.Signals2  Douglas Gregor   Frank Mori Hess  Copyright &#169; 2001-2004 Douglas Gregor Copyright &#169; 2007-2009 Frank Mori Hess  Distributed under the Boost     Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)    Table of Contents  Introduction Signals2 Tutorial  How to Read this Tutorial Hello, World! (Beginner) Calling Multiple Slots Passing Values to and from Slots Connection Management Example: Document-View Giving a Slot Access to its Connection (Advanced) Changing the Mutex Type of a Signal (Advanced). Linking against the Signals2 library  Example programs  Miscellaneous Tutorial Examples Document-View Postconstructors and Predestructors with deconstruct()  Reference  Header &lt;boost/signals2.hpp&gt; Header &lt;boost/signals2/connection.hpp&gt; Header &lt;boost/signals2/deconstruct.hpp&gt; Header &lt;boost/signals2/dummy_mutex.hpp&gt; Header &lt;boost/signals2/last_value.hpp&gt; Header &lt;boost/signals2/mutex.hpp&gt; Header &lt;boost/signals2/optional_last_value.hpp&gt; Header &lt;boost/signals2/shared_connection_block.hpp&gt; Header &lt;boost/signals2/signal.hpp&gt; Header &lt;boost/signals2/signal_base.hpp&gt; Header &lt;boost/signals2/signal_type.hpp&gt; Header &lt;boost/signals2/slot.hpp&gt; Header &lt;boost/signals2/slot_base.hpp&gt; Header &lt;boost/signals2/trackable.hpp&gt;  Thread-Safety  Introduction Signals and combiners Connections and other classes  Frequently Asked Questions Design Rationale  User-level Connection Management Automatic Connection Management optional_last_value as the Default Combiner Combiner Interface Connection Interfaces: +=  operator Signals2 Mutex Classes Comparison with other Signal/Slot implementations  Signals2 API Changes  Porting from Boost.Signals to Boost.Signals2 Signals2 API Development  Testsuite Acceptance tests     Introduction Signals2 The Boost.Signals2 library is an implementation of a managed   signals and slots system. Signals represent callbacks with multiple   targets, and are also called publishers or events in similar   systems. Signals are connected to some set of slots, which are   callback receivers (also called event targets or subscribers), which   are called when the signal is "emitted." Signals and slots are managed, in that signals and slots (or,   more properly, objects that occur as part of the slots) can track   connections and are capable of automatically disconnecting signal/slot   connections when either is destroyed. This enables the user to make   signal/slot connections without expending a great effort to manage the   lifetimes of those connections with regard to the lifetimes of all   objects involved. When signals are connected to multiple slots, there is a   question regarding the relationship between the return values of the   slots and the return value of the signals. Boost.Signals2 allows the   user to specify the manner in which multiple return values are   combined.   Signals2 This documentation describes a thread-safe variant of the     original Boost.Signals library.  There have been some changes to     the interface to support thread-safety, mostly with respect to     automatic connection management.  This implementation was written by     Frank Mori Hess.  Acknowledgements are also due to Timmo Stange, Peter     Dimov, and Tony Van Eerd for ideas and feedback, and to Douglas Gregor     for the original version of Boost.Signals this effort was based on.          Last revised: June 12, 2007 at 14:01:23 -0400         
Chapter&#160;29.&#160;Boost String Algorithms Libraryhttps://www.boost.org/doc/libs/1_59_0/doc/string_algo.html    Chapter&#160;29.&#160;Boost String Algorithms Library           Home Libraries People FAQ More         Chapter&#160;29.&#160;Boost String Algorithms Library  Pavol Droba  Copyright &#169; 2002-2004 Pavol Droba  Use, modification and distribution is subject to the Boost                 Software License, Version 1.0. (See accompanying file                 LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                 Table of Contents  Introduction Release Notes Usage  First Example Case conversion Predicates and Classification Trimming Find algorithms Replace Algorithms Find Iterator Split  Quick Reference  Algorithms Finders and Formatters Iterators Classification  Design Topics  String Representation Sequence Traits Find Algorithms Replace Algorithms Find Iterators &amp; Split Algorithms Exception Safety  Concepts  Definitions Finder Concept Formatter concept  Reference  Header &lt;boost/algorithm/string.hpp&gt; Header &lt;boost/algorithm/string/case_conv.hpp&gt; Header &lt;boost/algorithm/string/classification.hpp&gt; Header &lt;boost/algorithm/string/compare.hpp&gt; Header &lt;boost/algorithm/string/concept.hpp&gt; Header &lt;boost/algorithm/string/constants.hpp&gt; Header &lt;boost/algorithm/string/erase.hpp&gt; Header &lt;boost/algorithm/string/find.hpp&gt; Header &lt;boost/algorithm/string/find_format.hpp&gt; Header &lt;boost/algorithm/string/find_iterator.hpp&gt; Header &lt;boost/algorithm/string/finder.hpp&gt; Header &lt;boost/algorithm/string/formatter.hpp&gt; Header &lt;boost/algorithm/string/iter_find.hpp&gt; Header &lt;boost/algorithm/string/join.hpp&gt; Header &lt;boost/algorithm/string/predicate.hpp&gt; Header &lt;boost/algorithm/string/regex.hpp&gt; Header &lt;boost/algorithm/string/regex_find_format.hpp&gt; Header &lt;boost/algorithm/string/replace.hpp&gt; Header &lt;boost/algorithm/string/sequence_traits.hpp&gt; Header &lt;boost/algorithm/string/split.hpp&gt; Header &lt;boost/algorithm/string/std_containers_traits.hpp&gt; Header &lt;boost/algorithm/string/trim.hpp&gt; Header &lt;boost/algorithm/string/trim_all.hpp&gt; Header &lt;boost/algorithm/string_regex.hpp&gt;  Rationale  Locales Regular Expressions  Environment  Build Examples Tests Portability  Credits Acknowledgments     Introduction          The String Algorithm Library provides a generic implementation of         string-related algorithms which are missing in STL. It is an extension         to the algorithms library of STL and it includes trimming, case conversion,          predicates and find/replace functions. All of them come in different variants          so it is easier to choose the best fit for a particular need.               The implementation is not restricted to work with a particular container          (like std::basic_string), rather it is as generic as         possible. This generalization is not compromising the performance since         algorithms are using container specific features when it means a performance         gain.                            Important note: In this documentation we use term string to              designate a sequence of characters stored in an arbitrary container.             A string is not restricted to std::basic_string and              character does not have to be char or wchar_t,             although these are most common candidates.                  Consult the design chapter to see precise specification of         supported string types.                     The library interface functions and classes are defined in namespace boost::algorithm, and         they are lifted into namespace boost via using declaration.               The documentation is divided into several sections. For a quick start read the          Usage section followed by          Quick Reference.          The Design Topics,         Concepts and Rationale         provide some explanation about the library design and structure an explain how it should be used.         See the Reference for the complete list of provided utilities         and algorithms. Functions and classes in the reference are organized by the headers in which they are defined.         The reference contains links to the detailed description for every entity in the library.                  
Chapter&#160;30.&#160;Thread 4.5.0https://www.boost.org/doc/libs/1_59_0/doc/thread.html    Chapter&#160;30.&#160;Thread 4.5.0           Home Libraries People FAQ More         Chapter&#160;30.&#160;Thread 4.5.0  Anthony Williams   Vicente J. Botet Escriba  Copyright &#169; 2007 -11 Anthony Williams Copyright &#169; 2011 -15 Vicente J. Botet Escriba           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Overview Using and building the library  Configuration Limitations  History Future Thread Management  Synopsis Tutorial Class thread Namespace this_thread Class thread_group EXTENSION  Scoped Threads  Motivation Tutorial Free Thread Functors Class strict_scoped_thread Class scoped_thread Non-member function       swap(scoped_thread&amp;,scoped_thread&amp;)  Synchronization  Tutorial Mutex Concepts Lock Options Lock Guard With Lock Guard Lock Concepts Lock Types Other Lock Types       - EXTENSION Lock functions Lock Factories       - EXTENSION Mutex Types Condition Variables One-time Initialization Barriers -- EXTENSION Latches -- EXPERIMENTAL Executors and Schedulers       -- EXPERIMENTAL Futures  Thread Local Storage Class       thread_specific_ptr Synchronized Data Structures  Synchronized Values       - EXPERIMENTAL Synchronized Queues --       EXPERIMENTAL  Parallel - Fork-Join -- EXPERIMENTAL  Fork-Join Reference -- EXPERIMENTAL  Time Requirements Deprecated Emulations  =delete emulation Move semantics Bool explicit       conversion Scoped Enums  Acknowledgments Conformance and Extension  C++11 standard Thread library C++14 standard Thread library       - accepted changes C++14 TS Extensions for Concurrency       V1  C++1z TS Concurrency - On going       proposals      Overview         Boost.Thread enables the use of multiple threads       of execution with shared data in portable C++ code. It provides classes and       functions for managing the threads themselves, along with others for synchronizing       data between the threads or providing separate copies of data specific to individual       threads.             The Boost.Thread library was originally written       and designed by William E. Kempf (version 1).             Anthony Williams version (version 2) was a major rewrite designed to closely       follow the proposals presented to the C++ Standards Committee, in particular       N2497,       N2320,       N2184,       N2139,       and N2094             Vicente J. Botet Escriba started (version 3) the adaptation to comply with       the accepted Thread C++11 library (Make use of Boost.Chrono and Boost.Move)       and the Shared       Locking Howard Hinnant proposal except for the upward conversions.       Some minor non-standard features have been added also as thread attributes,       reverse_lock, shared_lock_guard.             In order to use the classes and functions described here, you can either include       the specific headers specified by the descriptions of each class or function,       or include the master thread library header:      #include &lt;boost/thread.hpp&gt;         which includes all the other headers in turn.         Last revised: August 04, 2015 at 09:07:22 GMT         
Part&#160;II.&#160;Boost Toolshttps://www.boost.org/doc/libs/1_59_0/doc/tools.html    Part&#160;II.&#160;Boost Tools           Home Libraries People FAQ More        Part&#160;II.&#160;Boost Tools            Boost developers, testers, and maintainers have developed various programs to          help with the administration of the Boost Libraries. Like everything else about          Boost, these tools are available in source form, and are part of the regular          Boost distribution.                 Users may find these tools useful when porting Boost libraries to a new platform,          or for use with their own applications.         Table of Contents  40. The BoostBook Documentation Format  Introduction Getting Started Documenting libraries Bringing Together a BoostBook Document Reference  41. Quickbook 1.6  Introduction Change Log Syntax Summary Document Structure Phrase Level Elements Block Level Elements Language Versions Installation and configuration Editor Support Frequently Asked Questions Quick Reference  42. Boost.Jam : 3.1.19  Building B2 Language Miscellaneous History  43. Boost.Build User Manual  Installation Tutorial Overview Common tasks Reference Extender Manual Frequently Asked Questions                
Concept Transformhttps://www.boost.org/doc/libs/1_59_0/doc/Transform.html    Concept Transform           Home Libraries People FAQ More         Concept Transform Transform   Description        A Transform is a PrimitiveTransform, a CallableTransform       or an ObjectTransform.        Associated types  result_type boost::result_of&lt;when&lt; _, Tn &gt;(Expr, State, Data)&gt;::type         The result of applying the Transform.          Notation  Tn A type playing the role of transform-type in the Transform concept. Expr A type playing the role of expression-type in the Transform concept. State A type playing the role of state-type in the Transform concept. Data A type playing the role of data-type in the Transform concept. expr Object of type Expr state Object of type State data Object of type Data    Valid expressions         Name Expression Type Semantics   Apply Transform when&lt; _, Tn &gt;()(expr, state, data) result_type Applies the transform.     Models boost::proto::_child(boost::proto::_left)     Copyright &#169; 2008 Eric Niebler         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Chapter&#160;32.&#160;Boost.Triboolhttps://www.boost.org/doc/libs/1_59_0/doc/tribool.html    Chapter&#160;32.&#160;Boost.Tribool           Home Libraries People FAQ More         Chapter&#160;32.&#160;Boost.Tribool   Douglas Gregor  &lt;dgregor -at- cs.indiana.edu&gt;  Copyright &#169; 2002-2004 Douglas Gregor  Use, modification and distribution is subject to the Boost     Software License, Version 1.0. (See accompanying file     LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)    Table of Contents  Introduction Tutorial  Basic usage Renaming the indeterminate state tribool input/output  Reference  Header &lt;boost/logic/tribool.hpp&gt; Header &lt;boost/logic/tribool_fwd.hpp&gt; Header &lt;boost/logic/tribool_io.hpp&gt;  Testsuite Acceptance tests     Introduction The 3-state boolean library contains a single class,     boost::logic::tribool, along with     support functions and operator overloads that implement 3-state     boolean logic.     Last revised: May 03, 2007 at 03:28:53 GMT         
Chapter&#160;35.&#160;Boost.Typeofhttps://www.boost.org/doc/libs/1_59_0/doc/typeof.html    Chapter&#160;35.&#160;Boost.Typeof           Home Libraries People FAQ More         Chapter&#160;35.&#160;Boost.Typeof  Arkadiy Vertleyb   Peder Holt  Copyright &#169; 2004, 2005 Arkadiy Vertleyb, Peder Holt           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at          http://www.boost.org/LICENSE_1_0.txt )           Table of Contents  Motivation Tutorial Reference  AUTO, AUTO_TPL COMPLIANT INCREMENT_REGISTRATION_GROUP INTEGRAL LIMIT_FUNCTION_ARITY MESSAGES LIMIT_SIZE REGISTER_TYPE REGISTER_TEMPLATE TEMPLATE TYPEOF, TYPEOF_TPL TYPEOF_NESTED_TYPEDEF, TYPEOF_NESTED_TYPEDEF_TPL  Other considerations and tips  Native typeof support and emulation The three participating parties Supported features What needs to be registered? Limitations  Contributed By: Acknowledgements     Motivation        Today many template libraries supply object generators to simplify object creation       by utilizing the C++ template argument deduction facility. Consider std::pair.       In order to instantiate this class template and create a temporary object of       this instantiation, one has to supply template parameters, as well as parameters       to the constructor:      std::pair&lt;int, double&gt;(5, 3.14159);         To avoid this duplication, STL supplies the std::make_pair       object generator. When it is used, the types of template parameters are deduced       from supplied function arguments:      std::make_pair(5, 3.14159);         For the temporary objects it is enough. However, when a named object needs       to be allocated, the problem appears again:      std::pair&lt;int, double&gt; p(5, 3.14159);         The object generator no longer helps:      std::pair&lt;int, double&gt; p = std::make_pair(5, 3.14159);         It would be nice to deduce the type of the object (on the left) from the expression       it is initialized with (on the right), but the current C++ syntax does not       allow for this.             The above example demonstrates the essence of the problem but does not demonstrate       its scale. Many libraries, especially expression template libraries, create       objects of really complex types, and go a long way to hide this complexity       behind object generators. Consider a nit Boost.Lambda functor:      _1 &gt; 15 &amp;&amp; _2 &lt; 20         If one wanted to allocate a named copy of such an innocently looking functor,       she would have to specify something like this:      lambda_functor&lt;     lambda_functor_base&lt;         logical_action&lt;and_action&gt;,         tuple&lt;             lambda_functor&lt;                 lambda_functor_base&lt;                     relational_action&lt;greater_action&gt;,                     tuple&lt;                         lambda_functor&lt;placeholder&lt;1&gt; &gt;,                         int const                     &gt;                 &gt;             &gt;,             lambda_functor&lt;                 lambda_functor_base&lt;                     relational_action&lt;less_action&gt;,                     tuple&lt;                         lambda_functor&lt;placeholder&lt;2&gt; &gt;,                         int const                     &gt;                 &gt;             &gt;         &gt;     &gt; &gt; f = _1 &gt; 15 &amp;&amp; _2 &lt; 20;         Not exactly elegant. To solve this problem (as well as some other problems),       the C++ standard committee is considering a few additions to the standard language,       such as typeof/decltype and auto       (see http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1607.pdf).             The typeof operator (or decltype, which is a slightly different flavor       of typeof) allows one to determine       the type of an expression at compile time. Using typeof,       the above example can be simplified drastically:      typeof(_1 &gt; 15 &amp;&amp; _2 &lt; 20) f = _1 &gt; 15 &amp;&amp; _2 &lt; 20;         Much better, but some duplication still exists. The auto       type solves the rest of the problem:      auto f = _1 &gt; 15 &amp;&amp; _2 &lt; 20;         The purpose of the Boost.Typeof library is to provide a library-based solution,       which could be used until the language-based facility is added to the Standard       and becomes widely available.                  
Chapter&#160;37.&#160;Boost.Unorderedhttps://www.boost.org/doc/libs/1_59_0/doc/unordered.html    Chapter&#160;37.&#160;Boost.Unordered           Home Libraries People FAQ More         Chapter&#160;37.&#160;Boost.Unordered  Daniel James  Copyright &#169; 2003, 2004 Jeremy B. Maitin-Shepard Copyright &#169; 2005-2008 Daniel       James           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction The Data Structure Equality Predicates and Hash Functions Comparison with Associative Containers C++11 Compliance  Move emulation Use of allocators Pairs Miscellaneous  Implementation Rationale Change Log Reference  Header &lt;boost/unordered_set.hpp&gt; Header &lt;boost/unordered_map.hpp&gt;  Bibliography     Introduction         For accessing data based on key lookup, the C++ standard library offers std::set,       std::map, std::multiset       and std::multimap. These are generally implemented       using balanced binary trees so that lookup time has logarithmic complexity.       That is generally okay, but in many cases a hash       table can perform better, as accessing data has constant complexity,       on average. The worst case complexity is linear, but that occurs rarely and       with some care, can be avoided.             Also, the existing containers require a 'less than' comparison object to order       their elements. For some data types this is impossible to implement or isn't       practical. In contrast, a hash table only needs an equality function and a       hash function for the key.             With this in mind, unordered associative containers were added to the C++ standard.       This is an implementation of the containers described in C++11, with some       deviations from the standard in       order to work with non-C++11 compilers and libraries.             unordered_set and unordered_multiset are defined in the header       &lt;boost/unordered_set.hpp&gt;      namespace boost {     template &lt;         class Key,         class Hash = boost::hash&lt;Key&gt;,         class Pred = std::equal_to&lt;Key&gt;,         class Alloc = std::allocator&lt;Key&gt; &gt;     class unordered_set;      template&lt;         class Key,         class Hash = boost::hash&lt;Key&gt;,         class Pred = std::equal_to&lt;Key&gt;,         class Alloc = std::allocator&lt;Key&gt; &gt;     class unordered_multiset; }         unordered_map and unordered_multimap are defined in the header       &lt;boost/unordered_map.hpp&gt;      namespace boost {     template &lt;         class Key, class Mapped,         class Hash = boost::hash&lt;Key&gt;,         class Pred = std::equal_to&lt;Key&gt;,         class Alloc = std::allocator&lt;std::pair&lt;Key const, Mapped&gt; &gt; &gt;     class unordered_map;      template&lt;         class Key, class Mapped,         class Hash = boost::hash&lt;Key&gt;,         class Pred = std::equal_to&lt;Key&gt;,         class Alloc = std::allocator&lt;std::pair&lt;Key const, Mapped&gt; &gt; &gt;     class unordered_multimap; }         When using Boost.TR1, these classes are included from &lt;unordered_set&gt;       and &lt;unordered_map&gt;, with the classes added to the std::tr1       namespace.             The containers are used in a similar manner to the normal associative containers:        typedef boost::unordered_map&lt;std::string, int&gt; map; map x; x["one"] = 1; x["two"] = 2; x["three"] = 3;  assert(x.at("one") == 1); assert(x.find("missing") == x.end());               But since the elements aren't ordered, the output of:        BOOST_FOREACH(map::value_type i, x) {     std::cout&lt;&lt;i.first&lt;&lt;","&lt;&lt;i.second&lt;&lt;"\n"; }               can be in any order. For example, it might be:      two,2 one,1 three,3         To store an object in an unordered associative container requires both an key       equality function and a hash function. The default function objects in the       standard containers support a few basic types including integer types, floating       point types, pointer types, and the standard strings. Since Boost.Unordered       uses boost::hash it also supports       some other types, including standard containers. To use any types not supported       by these methods you have to extend Boost.Hash       to support the type or use your own custom equality predicates and hash       functions. See the Equality Predicates       and Hash Functions section for more details.             There are other differences, which are listed in the Comparison       with Associative Containers section.         Last revised: August 04, 2015 at 09:07:34 GMT         
Chapter&#160;38.&#160;Boost.Varianthttps://www.boost.org/doc/libs/1_59_0/doc/variant.html    Chapter&#160;38.&#160;Boost.Variant           Home Libraries People FAQ More         Chapter&#160;38.&#160;Boost.Variant  Eric Friedman   Itay Maman  Copyright &#169; 2002, 2003 Eric Friedman, Itay Maman  Distributed under the Boost Software License, Version 1.0.     (See accompanying file LICENSE_1_0.txt or copy at      http://www.boost.org/LICENSE_1_0.txt)         Table of Contents  Introduction  Abstract Motivation  Tutorial  Basic Usage Advanced Topics  Reference  Concepts Header &lt;boost/variant.hpp&gt; Header &lt;boost/variant/variant_fwd.hpp&gt; Header &lt;boost/variant/variant.hpp&gt; Header &lt;boost/variant/recursive_variant.hpp&gt; Header &lt;boost/variant/recursive_wrapper.hpp&gt; Header &lt;boost/variant/apply_visitor.hpp&gt; Header &lt;boost/variant/multivisitors.hpp&gt; Header &lt;boost/variant/get.hpp&gt; Header &lt;boost/variant/polymorphic_get.hpp&gt; Header &lt;boost/variant/bad_visit.hpp&gt; Header &lt;boost/variant/static_visitor.hpp&gt; Header &lt;boost/variant/visitor_ptr.hpp&gt;  Design Overview "Never-Empty" Guarantee Miscellaneous Notes  Boost.Variant vs. Boost.Any Portability Troubleshooting Acknowledgments  References     Introduction  Abstract Motivation    Abstract The variant class template is a safe, generic, stack-based discriminated union container, offering a simple solution for manipulating an object from a heterogeneous set of types in a uniform manner. Whereas standard containers such as std::vector may be thought of as "multi-value, single type," variant is "multi-type, single value." Notable features of boost::variant include:  Full value semantics, including adherence to standard     overload resolution rules for conversion operations. Compile-time type-safe value visitation via     boost::apply_visitor. Run-time checked explicit value retrieval via     boost::get. Support for recursive variant types via both     boost::make_recursive_variant and     boost::recursive_wrapper. Efficient implementation -- stack-based when possible (see     the section called &#8220;"Never-Empty" Guarantee&#8221; for more details).     Motivation  Problem Solution: A Motivating Example    Problem Many times, during the development of a C++ program, the programmer finds himself in need of manipulating several distinct types in a uniform manner. Indeed, C++ features direct language support for such types through its union  keyword: union { int i; double d; } u; u.d = 3.14; u.i = 3; // overwrites u.d (OK: u.d is a POD type) C++'s union construct, however, is nearly useless in an object-oriented environment. The construct entered the language primarily as a means for preserving compatibility with C, which supports only POD (Plain Old Data) types, and so does not accept types exhibiting non-trivial construction or destruction: union {   int i;   std::string s; // illegal: std::string is not a POD type! } u; Clearly another approach is required. Typical solutions feature the dynamic-allocation of objects, which are subsequently manipulated through a common base type (often a virtual base class     [Hen01] or, more dangerously, a void*). Objects of concrete type may be then retrieved by way of a polymorphic downcast construct (e.g., dynamic_cast, boost::any_cast, etc.). However, solutions of this sort are highly error-prone, due to the following:   Downcast errors cannot be detected at     compile-time. Thus, incorrect usage of downcast     constructs will lead to bugs detectable only at run-time.  Addition of new concrete types may be      ignored. If a new concrete type is added to the     hierarchy, existing downcast code will continue to work as-is,     wholly ignoring the new type. Consequently, the programmer must     manually locate and modify code at numerous locations, which often     results in run-time errors that are difficult to find.  Furthermore, even when properly implemented, these solutions tend to incur a relatively significant abstraction penalty due to the use of the heap, virtual function calls, and polymorphic downcasts.    Solution: A Motivating Example The boost::variant class template addresses these issues in a safe, straightforward, and efficient manner. The following example demonstrates how the class can be used: #include "boost/variant.hpp" #include &lt;iostream&gt;  class my_visitor : public boost::static_visitor&lt;int&gt; { public:     int operator()(int i) const     {         return i;     }          int operator()(const std::string &amp; str) const     {         return str.length();     } };  int main() {     boost::variant&lt; int, std::string &gt; u("hello world");     std::cout &lt;&lt; u; // output: hello world      int result = boost::apply_visitor( my_visitor(), u );     std::cout &lt;&lt; result; // output: 11 (i.e., length of "hello world") }                
Chapter&#160;39.&#160;Boost.Xpressivehttps://www.boost.org/doc/libs/1_59_0/doc/xpressive.html    Chapter&#160;39.&#160;Boost.Xpressive           Home Libraries People FAQ More         Chapter&#160;39.&#160;Boost.Xpressive  Eric Niebler  Copyright &#169; 2007 Eric Niebler           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Preface User's Guide  Introduction Installing       xpressive Quick Start Creating       a Regex Object Matching       and Searching Accessing       Results String       Substitutions String       Splitting and Tokenization Named Captures Grammars       and Nested Matches Semantic       Actions and User-Defined Assertions Symbol       Tables and Attributes Localization       and Regex Traits Tips 'N Tricks Concepts Examples  Reference  Header &lt;boost/xpressive/basic_regex.hpp&gt; Header &lt;boost/xpressive/match_results.hpp&gt; Header &lt;boost/xpressive/regex_actions.hpp&gt; Header &lt;boost/xpressive/regex_algorithms.hpp&gt; Header &lt;boost/xpressive/regex_compiler.hpp&gt; Header &lt;boost/xpressive/regex_constants.hpp&gt; Header &lt;boost/xpressive/regex_error.hpp&gt; Header &lt;boost/xpressive/regex_iterator.hpp&gt; Header &lt;boost/xpressive/regex_primitives.hpp&gt; Header &lt;boost/xpressive/regex_token_iterator.hpp&gt; Header &lt;boost/xpressive/regex_traits.hpp&gt; Header &lt;boost/xpressive/sub_match.hpp&gt; Header &lt;boost/xpressive/traits/c_regex_traits.hpp&gt; Header &lt;boost/xpressive/traits/cpp_regex_traits.hpp&gt; Header &lt;boost/xpressive/traits/null_regex_traits.hpp&gt; Header &lt;boost/xpressive/xpressive.hpp&gt; Header &lt;boost/xpressive/xpressive_dynamic.hpp&gt; Header &lt;boost/xpressive/xpressive_fwd.hpp&gt; Header &lt;boost/xpressive/xpressive_static.hpp&gt; Header &lt;boost/xpressive/xpressive_typeof.hpp&gt;  Acknowledgments Appendices  Appendix       1: History Appendix       2: Not Yet Implemented Appendix       3: Differences from Boost.Regex Appendix 4: Performance       Comparison Appendix       5: Implementation Notes      Preface           Wife: New Shimmer is a floor wax! Husband:         No, new Shimmer is a dessert topping! Wife: It's         a floor wax! Husband: It's a dessert topping!         Wife: It's a floor wax, I'm telling you! Husband:         It's a dessert topping, you cow! Announcer: Hey,         hey, hey, calm down, you two. New Shimmer is both a floor wax and         a dessert topping!                 -- Saturday Night Live                Description             xpressive is an advanced, object-oriented regular expression template library       for C++. Regular expressions can be written as strings that are parsed at run-time,       or as expression templates that are parsed at compile-time. Regular expressions       can refer to each other and to themselves recursively, allowing you to build       arbitrarily complicated grammars out of them.              Motivation             If you need to manipulate text in C++, you have typically had two disjoint       options: a regular expression engine or a parser generator. Regular expression       engines (like Boost.Regex) are powerful       and flexible; patterns are represented as strings which can be specified at       runtime. However, that means that syntax errors are likewise not detected until       runtime. Also, regular expressions are ill-suited to advanced text processing       tasks such as matching balanced, nested tags. Those tasks have traditionally       been handled by parser generators (like the Spirit       Parser Framework). These beasts are more powerful but less flexible.       They generally don't allow you to arbitrarily modify your grammar rules on       the fly. In addition, they don't have the exhaustive backtracking semantics       of regular expressions, which can make it more challenging to author some types       of patterns.             xpressive brings these two approaches seamlessly together and occupies a unique       niche in the world of C++ text processing. With xpressive, you can choose to       use it much as you would use Boost.Regex,       representing regular expressions as strings. Or you can use it as you would       use Spirit, writing your       regexes as C++ expressions, enjoying all the benefits of an embedded language       dedicated to text manipulation. What's more, you can mix the two to get the       benefits of both, writing regular expression grammars       in which some of the regular expressions are statically bound -- hard-coded       and syntax-checked by the compiler -- and others are dynamically bound and       specified at runtime. These regular expressions can refer to each other recursively,       matching patterns in strings that ordinary regular expressions cannot.              Influences       and Related Work             The design of xpressive's interface has been strongly influenced by John Maddock's       Boost.Regex library and his proposal       to add regular expressions to the Standard Library. I also drew a great deal       of inspiration from Joel de Guzman's Spirit       Parser Framework, which served as the model for static xpressive. Other       sources of inspiration are the Perl       6 redesign and GRETA.       (You can read a summary of the changes Perl 6 will bring to regex culture       here.)         Last revised: August 04, 2015 at 09:07:51 GMT         
